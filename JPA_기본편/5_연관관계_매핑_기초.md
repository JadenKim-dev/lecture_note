### 연관관계 매핑 기초

객체지향 설계의 목표는 자율적인 객체들의 협력 공동체를 만드는 것이다.  
객체간의 협력을 위해서는, 객체간 연관관계를 만드는 작업이 필수적이다.

예제 시나리오를 다음과 같이 가정하자

- 회원과 팀이 있다.
- 회원은 하나의 팀에만 소속될 수 있고, 회원과 팀은 다대일 관계다.

객체를 테이블에 맞추어 모델링하면 다음과 같이 참조를 통한 객체 간 연관관계가 없어진다.

<img src="./images/5_RelationMappingBasic_1.png" width="500px;" />

객체를 테이블에 맞추어 데이터 중심으로 모델링하면 객체 간 협력 관계를 만들 수 없다.  
테이블과 객체 사이에는 아래와 같은 큰 간격이 존재한다.

- **테이블**은 **외래 키로 조인**을 사용해서 연관된 테이블을 찾는다.
- **객체**는 **참조**를 사용해서 연관된 객체를 찾는다.

```java
// src/main/java/hellojpa/Member
@Entity
public class Member {
  @Id @GeneratedValue
  @Column(name = "MEMBER_ID")
  private Long id;

  @Column(name = "USERNAME")
  private String username;

  // 외래키를 프로퍼티로 가지고 있음
  @Column(name = "TEAM_ID")
  private Long teamId;

  …  // getter, setter 정의
}
```

```java
// src/main/java/hellojpa/Team
@Entity
public class Team {
    @Id @GeneratedValue
    @Column(name = "TEAM_ID")
    private Long id;

    private String name;

    …  // getter, setter 정의
}
```

```java
※ src/main/java/hellojpa/JpaMain
…
Team team = new Team();
team.setName("TeamA");
em.persist(team);

Member member = new Member();
member.setUsername("member1");
member.setTeamId(team.getId());  // 식별자로 객체 간 연관관계를 설정
em.persist(member);

Member findMember = em.find(Member.class, member.getId());
// findMember가 속한 팀을 조회하고 싶은 경우, id를 사용해서 영속성 컨텍스트에서 조회해야 한다
Long findTeamId = findMember.getTeamId();
Team findTeam = em.find(Team.class, findTeamId);

tx.commit();
```

### 단방향 연관관계

객체지향다운 모델링은 아래와 같다.

<img src="./images/5_RelationMappingBasic_2.png" width="400px;" />

먼저 엔티티 객체에는 다음과 같이 연관관계가 있는 객체에 대한 참조를 가지게 하고, @ManyToOne, @JoinColumn 어노테이션을 추가해서 관계를 설정한다.

```java
// src/main/java/hellojpa/Member
@Entity
public class Member {
    …
    @ManyToOne  // Member 입장에서 many, Team 입장에서 one
    @JoinColumn(name = "TEAM_ID")  // join해야 하는 column을 명시
    private Team team;
}
```

이제 엔티티 저장 시에는 연관관계를 설정할 엔티티를 조회하고, 참조에 객체를 넣어주면 된다.  
JPA가 알아서 연관관계 엔티티의 pk값을 꺼내서, insert시 foreign key로 사용하여 쿼리를 생성한다.

```java
// src/main/java/hellojpa/JpaMain
/**
 * 단방향 연관관계 저장
 */
Team team = new Team();
team.setName("TeamA");
em.persist(team);

Team team2 = new Team();
team.setName("TeamB");
em.persist(team2);

Member member = new Member();
member.setUsername("member1");
member.setTeam(team);
em.persist(member);

em.flush();
em.clear();   // 쿼리를 보기 위해 일부러 flush, clear

/**
 * 단방향 연관관계 조회
 */
Member findMember = em.find(Member.class, member.getId());
// findMember가 속한 팀을 조회
Team findTeam = findMember.getTeam();  // em.flush(); em.clear; 하지 않았다면 1차 캐시에서 가져왔을 것
System.out.println("findTeam = " + findTeam.getName());

// 수정
Team newTeam = em.find(Team.class, 2L);
findMember.setTeam(newTeam);

tx.commit();
```

```bash
> … # Team1, Team2에 대한 INSERT 문
Hibernate:
    /* insert hellojpa.Member      # member1 INSERT
        */ insert
        into
            Member
            (TEAM_ID, USERNAME, MEMBER_ID)
        values
            (?, ?, ?)

…
    select
        member0_.MEMBER_ID as MEMBER_I1_0_0_,
        member0_.TEAM_ID as TEAM_ID3_0_0_,
        member0_.USERNAME as USERNAME2_0_0_,
        team1_.TEAM_ID as TEAM_ID1_1_1_,
        team1_.name as name2_1_1_
    from
        Member member0_
    left outer join        # member와 team을 join해서 가져옴
        Team team1_
            on member0_.TEAM_ID=team1_.TEAM_ID
    where
        member0_.MEMBER_ID=?
findTeam = TeamB
…       // new Team 조회
    /* update
        hellojpa.Member */ update # member1 UPDATE
            Member
        set
            TEAM_ID=?,
            USERNAME=?
        where
            MEMBER_ID=?
```
