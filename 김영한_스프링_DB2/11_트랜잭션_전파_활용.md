### 트랜잭션 전파 활용1 - 예제 프로젝트 시작

예제를 통해 지금까지 학습한 트랜잭션 전파를 이해해보자.  
예제는 회원을 등록 및 조회하고, 회원의 가입 이력을 LOG 테이블에 남기도록 구현할 것이다.

먼저 회원 정보를 저장할 Member 엔티티를 정의한다.

```java
package hello.springtx.propagation;

@Entity
@Getter @Setter
public class Member {

    @Id @GeneratedValue
    private Long id;
    private String username;

    public Member() {
    }

    public Member(String username) {
        this.username = username;
    }
}
```

그리고 회원 정보를 저장 및 조회하는데 사용할 MemverRepository를 정의한다.  
보다 명확하게 로직을 확인하기 위해 순수 JPA를 사용하여 구현한다.

```java
package hello.springtx.propagation;

@Slf4j
@Repository
@RequiredArgsConstructor
public class MemberRepository {

    private final EntityManager em;

    @Transactional
    public void save(Member member) {
        log.info("member 저장");
        em.persist(member);
    }

    public Optional<Member> find(String username) {
        return em.createQuery("select m from Member m where m.username = :username", Member.class)
                .setParameter("username", username)
                .getResultList().stream().findAny();
    }
}
```

이제 가입 이력을 저장할 Log 엔티티를 정의하고, 이를 저장 및 조회하는 LogRepository를 정의한다.  
이 때 저장 시에 로그 메시지에 `로그예외` 문자열이 포함되면 런타임 예외가 발생하여 트랜잭션이 롤백되도록 로직을 추가했다.

```java
package hello.springtx.propagation;

@Entity
@Getter @Setter
public class Log {

    @Id @GeneratedValue
    private Long id;
    private String message;

    public Log() {
    }

    public Log(String message) {
        this.message = message;
    }
}
```

```java
package hello.springtx.propagation;

@Slf4j
@Repository
@RequiredArgsConstructor
public class LogRepository {

    private final EntityManager em;

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void save(Log logMessage) {
        log.info("log 저장");
        em.persist(logMessage);

        if (logMessage.getMessage().contains("로그예외")) {
            log.info("log 저장시 예외 발생");
            throw new RuntimeException("예외 발생");
        }

    }

    public Optional<Log> find(String message) {
        return em.createQuery("select l from Log l where l.message = :message", Log.class)
                .setParameter("message", message)
                .getResultList().stream().findAny();
    }
}
```

이제 회원을 관리하는 MemberService를 정의한다.  
먼저 joinV1()은 트랜잭션 설정 없이 Member와 Log 엔티티를 순차적으로 저장한다.  
이 때 레포지토리의 메서드에는 각각 @Transactional이 붙어 있기 때문에 별도로 트랜잭션이 시작된다.

다음으로 joinV2()는 Log 엔티티 저장 메서드 호출 부분을 try - catch로 묶어서 처리하도록 구현했다.  
로그 저장에 실패했다고 해서 회원 가입을 막을 필요는 없다고 생각될 때 이와 같이 구현할 수 있다.

```java
package hello.springtx.propagation;

@Slf4j
@Service
@RequiredArgsConstructor
public class MemberService {

    private final MemberRepository memberRepository;
    private final LogRepository logRepository;

    public void joinV1(String username) {
        Member member = new Member(username);
        Log logMessage = new Log(username);

        log.info("== memberRepository 호출 시작 ==");
        memberRepository.save(member);
        log.info("== memberRepository 호출 종료 ==");

        log.info("== logRepository 호출 시작 ==");
        logRepository.save(logMessage);
        log.info("== logRepository 호출 종료 ==");
    }

    public void joinV2(String username) {
        Member member = new Member(username);
        Log logMessage = new Log(username);

        log.info("== memberRepository 호출 시작 ==");
        memberRepository.save(member);
        log.info("== memberRepository 호출 종료 ==");

        log.info("== logRepository 호출 시작 ==");
        try {
            logRepository.save(logMessage);
        } catch (RuntimeException e) {
            log.info("log 저장에 실패했습니다. logMessage={}", logMessage.getMessage());
            log.info("정상 흐름 반환");
        }

        log.info("== logRepository 호출 종료 ==");
    }
}
```

joinV1()의 정상 케이스에 대한 테스트 코드는 다음과 같이 작성할 수 있다.  
memberService.joinV1을 호출하여 멤버 및 로그를 저장하고, 제대로 조회가 되는지 테스트한다.

```java
package hello.springtx.propagation;

@Slf4j
@SpringBootTest
class MemberServiceTest {

    @Autowired
    MemberService memberService;
    @Autowired
    MemberRepository memberRepository;
    @Autowired
    LogRepository logRepository;

    /**
     * memberService    @Transactional:OFF
     * memberRepository @Transactional:ON
     * logRepository    @Transactional:ON
     */
    @Test
    void outerTxOff_success() {
        //given
        String username = "outerTxOff_success";

        //when
        memberService.joinV1(username);

        //when: 모든 데이터가 정상 저장된다.
        assertTrue(memberRepository.find(username).isPresent());
        assertTrue(logRepository.find(username).isPresent());
    }
}
```

### 트랜잭션 전파 활용2 - 커밋, 롤백

outerTxOff_success() 테스트 케이스에서는 서비스 단에는 트랜잭션을 적용하지 않고, 레포지토리에 각각 적용한 상태에서 멤버와 로그를 저장했다.  
이로 인해 멤버, 로그를 저장할 때 각각 트랜잭션을 시작하여 별도로 처리하게 된다.

<img src="./images/11_트랜잭션_전파_활용_1.png" width="350px;" />

이에 대한 플로우는 다음과 같다.  
서비스 단에서 멤버를 저장하기 위해 트랜잭션 매니저를 통해 트랜잭션을 시작한다.  
이후에 멤버 저장을 레포지토리에 요청하면, 레포지토리에서는 트랜잭션이 적용된 커넥션을 동기화 매니저로부터 받아와서 멤버를 저장한다.  
이제 트랜잭션 매니저에 커밋을 요청하면 해당 커넥션을 통해 트랜잭션을 커밋하고, 커넥션은 반환된다.  
로그를 저장할 때에는 새롭게 커넥션을 받아와서 트랜잭션을 시작하게 된다.

<img src="./images/11_트랜잭션_전파_활용_2.png" width="500px;" />

이번에는 로그 저장 과정에서 런타임 예외가 발생하도록 테스트 케이스를 작성해보자.  
로그 레포지토리의 save()는 username에 `로그예외`가 포함되면 런타임 예외가 발생하도록 구현했었다.

```java
/**
 * memberService    @Transactional:ON
 * memberRepository @Transactional:ON
 * logRepository    @Transactional:ON Exception
 */
@Test
void outerTxOn_fail() {
    //given
    String username = "로그예외_outerTxOn_fail";

    //when
    assertThatThrownBy(() -> memberService.joinV1(username))
            .isInstanceOf(RuntimeException.class);

    //when: 모든 데이터가 롤백된다.
    assertTrue(memberRepository.find(username).isEmpty());
    assertTrue(logRepository.find(username).isEmpty());
}
```

username에 따라 런타임 예외가 발생하고, 트랜잭션 AOP에서는 이를 확인하고 트랜잭션을 롤백한다.  
따라서 로그는 저장에 실패하게 되고, 조회가 불가능하다.  
하지만 멤버 저장 시 시작한 트랜잭션과 로그 저장 시 시작한 트랜잭션이 구분되기 때문에, 멤버는 정상적으로 저장되어 조회가 가능하다.

<img src="./images/11_트랜잭션_전파_활용_3.png" width="350px;" />

실제로 롤백이 발생하는 플로우는 다음과 같다.  
LogRepository에서 런타임 예외가 발생하면, 이것을 트랜잭션 AOP 단에서 받게 된다.  
트랜잭션 AOP는 런타임 예외가 발생했음을 확인하고 트랜잭션 매니저에 롤백을 요청한다.  
이 때 롤백을 수행하는 db 커넥선은 member를 저장할 때 사용한 커넥션과 다르기 때문에, 별도로 롤백된다.

<img src="./images/11_트랜잭션_전파_활용_4.png" width="500px;" />

다만 위와 같이 구현할 경우 멤버와 로그 정보의 정합성이 저하된다.  
만약 두 데이터의 정합성이 중요한 상황이라면 하나의 트랜잭션으로 두 작업을 묶어야 한다.

### 트랜잭션 전파 활용3 - 단일 트랜잭션

두 개의 작업을 하나로 묶는 가장 쉬운 방법은, 서비스 단에 트랜잭션을 적용하고 레포지토리에는 적용하지 않는 것이다.  
이를 위해 서비스 단에 @Transactional을 붙이고, 레포지토리에 붙였던 @Transactional은 제거한다.

```java
    /**
     * memberService    @Transactional:ON
     * memberRepository @Transactional:OFF
     * logRepository    @Transactional:OFF
     */
    @Test
    void singleTx() {
        //given
        String username = "singleTx";

        //when
        memberService.joinV1(username);

        //when: 모든 데이터가 정상 저장된다.
        assertTrue(memberRepository.find(username).isPresent());
        assertTrue(logRepository.find(username).isPresent());
    }
```

이렇게 구성하면 서비스 로직을 실행하는 동안 하나의 트랜잭션으로 묶이게 된다.  

<img src="./images/11_트랜잭션_전파_활용_5.png" width="500px;" />

처음에 트랜잭션 설정 시 사용한 커넥션을 로직이 끝날 때까지 사용하게 되어서, 레포지토리 단에서는 동기화 매니저로부터 동일한 커넥션을 꺼내서 사용하게 된다.  
> 같은 쓰레드를 사용하면 동기화 매니저는 동일한 커넥션을 반환한다.

<img src="./images/11_트랜잭션_전파_활용_6.png" width="500px;" />

하지만 만약 서비스와 각 레포지토리에서 별도의 트랜잭션이 구성되는 상황이라면 어떻게 해야 할까?

<img src="./images/11_트랜잭션_전파_활용_7.png" width="500px;" />

레포지토리의 메서드는 여러 로직에서 사용될 수 있다.  
이 때 특정 로직에서는 상위의 트랜잭션에 묶이길 원하고, 다른 로직에서는 별도의 트랜잭션으로 구성되기를 원할 수 있다.  
만약 트랜잭션 전파 기능이 없다면 이 경우에는 @Transactional을 붙인 메서드와 붙이지 않은 메서드를 동시에 정의해야 할 것이다.

<img src="./images/11_트랜잭션_전파_활용_8.png" width="500px;" />

더 복잡하게는 트랜잭션을 적용한 서비스의 메서드를 다른 서비스에서 호출하는 상황도 가정해볼 수 있다.  
이와 같은 모단 경우에 대응하기 위해 메서드를 모두 중복해서 정의하는 것은 매우 번거롭다.

<img src="./images/11_트랜잭션_전파_활용_9.png" width="500px;" />

스프링에서는 이러한 문제를 해결하기 위해 트랜잭션 전파 기능을 제공하는 것이다.  
트랜잭션이 계층적으로 사용되는 상황에서도 @Transactional이 적절히 작동하도록 지원한다.

### 트랜잭션 전파 활용4 - 전파 커밋

<img src="./images/11_트랜잭션_전파_활용_10.png" width="500px;" />

<img src="./images/11_트랜잭션_전파_활용_11.png" width="500px;" />

<img src="./images/11_트랜잭션_전파_활용_12.png" width="500px;" />

<img src="./images/11_트랜잭션_전파_활용_13.png" width="500px;" />

### 트랜잭션 전파 활용5 - 전파 롤백

<img src="./images/11_트랜잭션_전파_활용_14.png" width="500px;" />

<img src="./images/11_트랜잭션_전파_활용_15.png" width="500px;" />

### 트랜잭션 전파 활용6 - 복구 REQUIRED

<img src="./images/11_트랜잭션_전파_활용_16.png" width="500px;" />

<img src="./images/11_트랜잭션_전파_활용_17.png" width="500px;" />

<img src="./images/11_트랜잭션_전파_활용_18.png" width="500px;" />

### 트랜잭션 전파 활용7 - 복구 REQUIRES_NEW

<img src="./images/11_트랜잭션_전파_활용_19.png" width="500px;" />

<img src="./images/11_트랜잭션_전파_활용_20.png" width="500px;" />

<img src="./images/11_트랜잭션_전파_활용_21.png" width="500px;" />

<img src="./images/11_트랜잭션_전파_활용_22.png" width="500px;" />
