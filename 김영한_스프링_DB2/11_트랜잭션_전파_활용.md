### 트랜잭션 전파 활용1 - 예제 프로젝트 시작

예제를 통해 지금까지 학습한 트랜잭션 전파를 이해해보자.  
예제는 회원을 등록 및 조회하고, 회원의 가입 이력을 LOG 테이블에 남기도록 구현할 것이다.

먼저 회원 정보를 저장할 Member 엔티티를 정의한다.

```java
package hello.springtx.propagation;

@Entity
@Getter @Setter
public class Member {

    @Id @GeneratedValue
    private Long id;
    private String username;

    public Member() {
    }

    public Member(String username) {
        this.username = username;
    }
}
```

그리고 회원 정보를 저장 및 조회하는데 사용할 MemverRepository를 정의한다.  
보다 명확하게 로직을 확인하기 위해 순수 JPA를 사용하여 구현한다.

```java
package hello.springtx.propagation;

@Slf4j
@Repository
@RequiredArgsConstructor
public class MemberRepository {

    private final EntityManager em;

    @Transactional
    public void save(Member member) {
        log.info("member 저장");
        em.persist(member);
    }

    public Optional<Member> find(String username) {
        return em.createQuery("select m from Member m where m.username = :username", Member.class)
                .setParameter("username", username)
                .getResultList().stream().findAny();
    }
}
```

이제 가입 이력을 저장할 Log 엔티티를 정의하고, 이를 저장 및 조회하는 LogRepository를 정의한다.  
이 때 저장 시에 로그 메시지에 `로그예외` 문자열이 포함되면 런타임 예외가 발생하여 트랜잭션이 롤백되도록 로직을 추가했다.  

```java
package hello.springtx.propagation;

@Entity
@Getter @Setter
public class Log {

    @Id @GeneratedValue
    private Long id;
    private String message;

    public Log() {
    }

    public Log(String message) {
        this.message = message;
    }
}
```

```java
package hello.springtx.propagation;

@Slf4j
@Repository
@RequiredArgsConstructor
public class LogRepository {

    private final EntityManager em;

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void save(Log logMessage) {
        log.info("log 저장");
        em.persist(logMessage);

        if (logMessage.getMessage().contains("로그예외")) {
            log.info("log 저장시 예외 발생");
            throw new RuntimeException("예외 발생");
        }

    }

    public Optional<Log> find(String message) {
        return em.createQuery("select l from Log l where l.message = :message", Log.class)
                .setParameter("message", message)
                .getResultList().stream().findAny();
    }
}
```

이제 회원을 관리하는 MemberService를 정의한다.  
먼저 joinV1()은 트랜잭션 설정 없이 Member와 Log 엔티티를 순차적으로 저장한다.  
이 때 레포지토리의 메서드에는 각각 @Transactional이 붙어 있기 때문에 별도로 트랜잭션이 시작된다.

다음으로 joinV2()는 Log 엔티티 저장 메서드 호출 부분을 try - catch로 묶어서 처리하도록 구현했다.  
로그 저장에 실패했다고 해서 회원 가입을 막을 필요는 없다고 생각될 때 이와 같이 구현할 수 있다.

```java
package hello.springtx.propagation;

@Slf4j
@Service
@RequiredArgsConstructor
public class MemberService {

    private final MemberRepository memberRepository;
    private final LogRepository logRepository;

    public void joinV1(String username) {
        Member member = new Member(username);
        Log logMessage = new Log(username);

        log.info("== memberRepository 호출 시작 ==");
        memberRepository.save(member);
        log.info("== memberRepository 호출 종료 ==");

        log.info("== logRepository 호출 시작 ==");
        logRepository.save(logMessage);
        log.info("== logRepository 호출 종료 ==");
    }

    public void joinV2(String username) {
        Member member = new Member(username);
        Log logMessage = new Log(username);

        log.info("== memberRepository 호출 시작 ==");
        memberRepository.save(member);
        log.info("== memberRepository 호출 종료 ==");

        log.info("== logRepository 호출 시작 ==");
        try {
            logRepository.save(logMessage);
        } catch (RuntimeException e) {
            log.info("log 저장에 실패했습니다. logMessage={}", logMessage.getMessage());
            log.info("정상 흐름 반환");
        }

        log.info("== logRepository 호출 종료 ==");
    }
}
```

joinV1()의 정상 케이스에 대한 테스트 코드는 다음과 같이 작성할 수 있다.  
memberService.joinV1을 호출하여 멤버 및 로그를 저장하고, 제대로 조회가 되는지 테스트한다.

```java
package hello.springtx.propagation;

@Slf4j
@SpringBootTest
class MemberServiceTest {

    @Autowired
    MemberService memberService;
    @Autowired
    MemberRepository memberRepository;
    @Autowired
    LogRepository logRepository;

    /**
     * memberService    @Transactional:OFF
     * memberRepository @Transactional:ON
     * logRepository    @Transactional:ON
     */
    @Test
    void outerTxOff_success() {
        //given
        String username = "outerTxOff_success";

        //when
        memberService.joinV1(username);

        //when: 모든 데이터가 정상 저장된다.
        assertTrue(memberRepository.find(username).isPresent());
        assertTrue(logRepository.find(username).isPresent());
    }
}
```

### 트랜잭션 전파 활용2 - 커밋, 롤백

outerTxOff_success() 테스트 케이스에서는 서비스 단에는 트랜잭션을 적용하지 않고, 레포지토리에 각각 적용한 상태에서 멤버와 로그를 저장했다.  
이로 인해 멤버, 로그를 저장할 때 각각 트랜잭션을 시작하여 별도로 처리하게 된다.

<img src="./images/11_트랜잭션_전파_활용_1.png" width="500px;" />

이에 대한 플로우는 다음과 같다.  
서비스 단에서 멤버를 저장하기 위해 트랜잭션 매니저를 통해 트랜잭션을 시작한다.  
이후에 멤버 저장을 레포지토리에 요청하면, 레포지토리에서는 트랜잭션이 적용된 커넥션을 동기화 매니저로부터 받아와서 멤버를 저장한다.  
이제 트랜잭션 매니저에 커밋을 요청하면 해당 커넥션을 통해 트랜잭션을 커밋하고, 커넥션은 반환된다.  
로그를 저장할 때에는 새롭게 커넥션을 받아와서 트랜잭션을 시작하게 된다.

<img src="./images/11_트랜잭션_전파_활용_2.png" width="500px;" />

이번에는 로그 저장 과정에서 런타임 예외가 발생하도록 테스트 케이스를 작성해보자.  
로그 레포지토리의 save()는 username에 `로그예외`가 포함되면 런타임 예외가 발생하도록 구현했었다.

```java
/**
 * memberService    @Transactional:ON
 * memberRepository @Transactional:ON
 * logRepository    @Transactional:ON Exception
 */
@Test
void outerTxOn_fail() {
    //given
    String username = "로그예외_outerTxOn_fail";

    //when
    assertThatThrownBy(() -> memberService.joinV1(username))
            .isInstanceOf(RuntimeException.class);

    //when: 모든 데이터가 롤백된다.
    assertTrue(memberRepository.find(username).isEmpty());
    assertTrue(logRepository.find(username).isEmpty());
}
```

username에 따라 런타임 예외가 발생하고, 트랜잭션 AOP에서는 이를 확인하고 트랜잭션을 롤백한다.  
따라서 로그는 저장에 실패하게 되고, 조회가 불가능하다.
하지만 멤버 저장 시 시작한 트랜잭션과 로그 저장 시 시작한 트랜잭션이 구분되기 때문에, 멤버는 정상적으로 저장되어 조회가 가능하다.

<img src="./images/11_트랜잭션_전파_활용_3.png" width="500px;" />


### 트랜잭션 전파 활용3 - 단일 트랜잭션

<img src="./images/11_트랜잭션_전파_활용_3.png" width="500px;" />

<img src="./images/11_트랜잭션_전파_활용_4.png" width="500px;" />

<img src="./images/11_트랜잭션_전파_활용_5.png" width="500px;" />

<img src="./images/11_트랜잭션_전파_활용_6.png" width="500px;" />

<img src="./images/11_트랜잭션_전파_활용_7.png" width="500px;" />

### 트랜잭션 전파 활용4 - 전파 커밋

<img src="./images/11_트랜잭션_전파_활용_8.png" width="500px;" />

<img src="./images/11_트랜잭션_전파_활용_9.png" width="500px;" />

<img src="./images/11_트랜잭션_전파_활용_10.png" width="500px;" />

<img src="./images/11_트랜잭션_전파_활용_11.png" width="500px;" />

### 트랜잭션 전파 활용5 - 전파 롤백

<img src="./images/11_트랜잭션_전파_활용_12.png" width="500px;" />

<img src="./images/11_트랜잭션_전파_활용_13.png" width="500px;" />

### 트랜잭션 전파 활용6 - 복구 REQUIRED

<img src="./images/11_트랜잭션_전파_활용_14.png" width="500px;" />

<img src="./images/11_트랜잭션_전파_활용_15.png" width="500px;" />

<img src="./images/11_트랜잭션_전파_활용_16.png" width="500px;" />

### 트랜잭션 전파 활용7 - 복구 REQUIRES_NEW

<img src="./images/11_트랜잭션_전파_활용_17.png" width="500px;" />

<img src="./images/11_트랜잭션_전파_활용_18.png" width="500px;" />

<img src="./images/11_트랜잭션_전파_활용_19.png" width="500px;" />

<img src="./images/11_트랜잭션_전파_활용_20.png" width="500px;" />
