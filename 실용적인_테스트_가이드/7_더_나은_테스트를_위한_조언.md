### 한 문단에 한 주제!

각각의 테스트는 하나의 문단이라고 볼 수 있고, 따라서 하나의 테스트에는 하나의 주제만 담겨 있는 것이 적절하다.  
예제를 살펴보면서 어떤 점을 주의하면서 작성하면 좋을지 생각해보자.

ProductType enum에는 재고가 적용되는 타입인지를 반환하는 containsStockType 메서드가 포함되어 있다.

```java
package sample.cafekiosk.spring.domain.product;

@Getter
@RequiredArgsConstructor
public enum ProductType {
    HANDMADE("제조 음료"),
    BOTTLE("병 음료"),
    BAKERY("베이커리");

    private final String text;

    public static boolean containsStockType(ProductType type) {
        return List.of(BOTTLE, BAKERY).contains(type);
    }
}
```

다음과 같이 반복문과 분기문을 사용하여 ProductType에 대한 테스트를 작성했다고 하자.  
모든 ProductType을 순회하면서, 각 케이스에 대해서 containsStockType이 잘 동작하는지 검증한다.

```java
package sample.cafekiosk.spring.domain.product;

class ProductTypeTest {

    @DisplayName("상품 타입이 재고 관련 타입인지를 체크한다.")
    @Test
    void containsStockType() {
        // given
        ProductType[] productTypes = ProductType.values();

        for (ProductType productType : productTypes) {
            if (produtType === ProductType.HANDMADE) {
                // when
                boolean result = ProductType.containsStockType(productType);

                // then
                assertThat(result).isFalse();
            }
            // when
            if (productType == ProductType.BOTTLE || productType == ProductType.BAKERY) {
                // when
                boolean result = ProductType.containsStockType(productType);

                // then
                assertThat(result).isTrue();
            }
        }
    }
}
```

위 경우에는 여러 가지의 테스트 케이스가 하나의 테스트로 작성된 것이라고 볼 수 있다.  
테스트에 분기문이나 반복문이 들어가면, 여러 가지의 주제를 하나의 테스트에 담으려고 시도하는 것으로 보면 된다.  
분기문이나 반복문이 들어가면 논리 구조를 이해하기 위한 노력이 필요해지고, 이로 인해 테스트가 무엇을 검증하고자 하는지, 어떤 환경을 구성하고자 하는지 이해하기 어려워진다.  
만약 테스트 확장이 필요하다면, 뒤에서 소개할 ParameterizedTest를 사용하거나, 테스트를 분리해서 작성해야 한다.

```java
package sample.cafekiosk.spring.domain.product;

class ProductTypeTest {
    @DisplayName("상품 타입이 재고 관련 타입인지를 체크한다.")
    @Test
    void containsStockType() {
        // given
        ProductType givenType = ProductType.HANDMADE;

        // when
        boolean result = ProductType.containsStockType(givenType);

        // then
        assertThat(result).isFalse();
    }

    @DisplayName("상품 타입이 재고 관련 타입인지를 체크한다.")
    @Test
    void containsStockType2() {
        // given
        ProductType givenType = ProductType.BAKERY;

        // when
        boolean result = ProductType.containsStockType(givenType);

        // then
        assertThat(result).isTrue();
    }
}
```

### 완벽하게 제어하기

테스트를 하기 위한 환경을 구성할 때에는, 모든 조건을 완벽하게 제어할 수 있어야 한다.  
현재 시간, 랜덤값을 매개변수로 받게 하거나, 외부 시스템과의 연동을 모킹 처리하는 등의 방법으로 제어 가능한 영역을 넓혀야 한다.

예제에서는 키오스크에서 주문 생성 시, 주문 생성 시간을 내부에서 계산하는 대신, 외부에서 매개변수로 받도록 createOrder 메서드를 오버로딩 했다.

```java
package sample.cafekiosk.unit;

@Getter
public class CafeKiosk {

    private static final LocalTime SHOP_OPEN_TIME = LocalTime.of(10, 0);
    private static final LocalTime SHOP_CLOSE_TIME = LocalTime.of(22, 0);

    private final List<Beverage> beverages = new ArrayList<>();

    ...

    public Order createOrder() {
        return createOrder(LocalDateTime.now());
    }

    public Order createOrder(LocalDateTime currentDateTime) {
        LocalTime currentTime = currentDateTime.toLocalTime();
        if (currentTime.isBefore(SHOP_OPEN_TIME) || currentTime.isAfter(SHOP_CLOSE_TIME)) {
            throw new IllegalArgumentException("주문 시간이 아닙니다. 관리자에게 문의하세요.");
        }

        return new Order(currentDateTime, beverages);
    }

}
```

이렇게 현재 시간을 구하는 부분을 제어 가능한 영역으로 만들었기 때문에, 다음과 같이 주문 성공 케이스와 실패 케이스를 구분하여 테스트를 작성할 수 있었다.

```java
package sample.cafekiosk.unit;

class CafeKioskTest {
    @Test
    void createOrderWithCurrentTime() {
        CafeKiosk cafeKiosk = new CafeKiosk();
        Americano americano = new Americano();
        cafeKiosk.add(americano);

        Order order = cafeKiosk.createOrder(LocalDateTime.of(2023, 1, 17, 10, 0));

        assertThat(order.getBeverages()).hasSize(1);
        assertThat(order.getBeverages().get(0).getName()).isEqualTo("아메리카노");
    }

    @Test
    void createOrderOutsideOpenTime() {
        CafeKiosk cafeKiosk = new CafeKiosk();
        Americano americano = new Americano();
        cafeKiosk.add(americano);

        assertThatThrownBy(() -> cafeKiosk.createOrder(LocalDateTime.of(2023, 1, 17, 9, 59)))
            .isInstanceOf(IllegalArgumentException.class)
            .hasMessage("주문 시간이 아닙니다. 관리자에게 문의하세요.");
    }

}
```

추가적으로, OrderTest에서 Order 객체 생성 시 LocalDateTime.now()를 사용하는 부분이 있었다.

```java
    @DisplayName("주문 생성 시 주문 등록 시간을 기록한다.")
    @Test
    void registeredDateTime() {
        // given
        LocalDateTime registeredDateTime = LocalDateTime.now();
        List<Product> products = List.of(
                createProduct("001", 1000),
                createProduct("002", 2000)
        );

        // when
        Order order = Order.create(products, registeredDateTime);

        // then
        assertThat(order.getRegisteredDateTime()).isEqualTo(registeredDateTime);
    }
```

위 경우는 단순히 해당 날짜가 정상적으로 삽입되었는지를 확인하는 테스트이기 때문에 문제가 없다고 생각할 수 있다.  
하지만 위와 같은 경우를 조금씩 허용하다 보면, 점점 LocalDateTime.now()와 같은 부분을 사용하는 부분이 늘어날 수 있다.  
또한 위 로직도 나중에는 어떻게 변경될지 모르기 때문에, 가능하면 처음부터 LocalDateTime.now()는 사용하지 않는 것으로 못을 박는게 좋다.  
다음과 같이 직접 특정 날짜를 지정하는게 적절하다.  
`LocalDateTime registeredDateTime = LocalDateTime.of(2023, 1, 17, 10, 0)`

### 테스트 환경의 독립성을 보장하자

테스트 환경을 구성하는 given 절에 다른 로직이 개입할 경우, 해당 로직에 의존적인 테스트가 된다.  
이전에 작성했던 OrderServiceTest의 다음 테스트를 살펴보자.

```java
    @DisplayName("재고가 부족한 상품으로 주문을 생성하려는 경우 예외가 발생한다.")
    @Test
    void createOrderWithNoStock() {
        // given
        LocalDateTime registeredDateTime = LocalDateTime.now();

        Product product1 = createProduct(BOTTLE, "001", 1000);
        Product product2 = createProduct(BAKERY, "002", 3000);
        Product product3 = createProduct(HANDMADE, "003", 5000);
        productRepository.saveAll(List.of(product1, product2, product3));

        Stock stock1 = Stock.create("001", 2);
        Stock stock2 = Stock.create("002", 2);
        stock1.deductQuantity(1); // todo
        stockRepository.saveAll(List.of(stock1, stock2));

        OrderCreateServiceRequest request = OrderCreateServiceRequest.builder()
                .productNumbers(List.of("001", "001", "002", "003"))
                .build();

        // when // then
        assertThatThrownBy(() -> orderService.createOrder(request, registeredDateTime))
                .isInstanceOf(IllegalArgumentException.class)
                .hasMessage("재고가 부족한 상품이 있습니다.");
    }
```

위 테스트는 환경 구성 과정에서 stock.deductQuantity 메서드가 개입되어 있다.  
이로 인해 given 절을 읽는 과정에서 deductQuantity를 이해하는데 신경을 써야 히는 문제가 있다.  
또한 deductQuantity를 실행하는 과정에서 예외가 터진 것으로 인해 테스트가 실패할 수 있다.  
테스트 대상이 되는 메서드가 아닌 다른 부분으로 인해 테스트가 실패하기 시작하면, 어디에 문제가 있는지 찾기 어려워진다.

given 절에는 가능한 생성자를 이용해 객체를 생성하고 저장하는 코드만 존재하는게 좋다.  
가능하면 Stock.create와 같은 팩터리 메서드도 사용을 지양하는게 좋다.  
팩터리 메서드는 인자 검증 등 특정 목적을 가지고 작성된 경우가 많기 때문에 위 문제점들을 동일하게 가질 수 있다.  
가능하면 생성자 또는 builder를 이용해서 순수하게 객체를 생성하는게 좋다.

### 테스트 간 독립성을 보장하자

이번에는 두 개 이상의 테스트 간의 독립성에 관해서 이야기 해보자.  
다음과 같이 테스트 클래스에서 객체를 생성하여 static으로 저장해두고, 각 테스트에서 공통으로 사용한다고 해보자.

```java
package sample.cafekiosk.spring.domain.stock;

class StockTest {
    private final Stock stock = Stock.create("001", 1);

    @DisplayName("재고의 수량이 제공된 수량보다 작은지 확인한다.")
    @Test
    void isQuantityLessThan() {
        // given
        int quantity = 2;

        // when
        boolean result = stock.isQuantityLessThan(quantity);

        // then
        assertThat(result).isTrue();
    }

    @DisplayName("재고를 주어진 개수만큼 차감할 수 있다.")
    @Test
    void deductQuantity() {
        // given
        int quantity = 1;

        // when
        stock.deductQuantity(quantity);

        // then
        assertThat(stock.getQuantity()).isZero();
    }

    @DisplayName("재고보다 많은 수의 수량으로 차감 시도하는 경우 예외가 발생한다.")
    @Test
    void deductQuantity2() {
        // given
        int quantity = 2;

        // when // then
        assertThatThrownBy(() -> stock.deductQuantity(quantity))
                .isInstanceOf(IllegalArgumentException.class)
                .hasMessage("차감할 재고 수량이 없습니다.");
    }

}




