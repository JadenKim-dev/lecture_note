### 한 문단에 한 주제!

각각의 테스트는 하나의 문단이라고 볼 수 있고, 따라서 하나의 테스트에는 하나의 주제만 담겨 있는 것이 적절하다.  
예제를 살펴보면서 어떤 점을 주의하면서 작성하면 좋을지 생각해보자.

ProductType enum에는 재고가 적용되는 타입인지를 반환하는 containsStockType 메서드가 포함되어 있다.

```java
package sample.cafekiosk.spring.domain.product;

@Getter
@RequiredArgsConstructor
public enum ProductType {
    HANDMADE("제조 음료"),
    BOTTLE("병 음료"),
    BAKERY("베이커리");

    private final String text;

    public static boolean containsStockType(ProductType type) {
        return List.of(BOTTLE, BAKERY).contains(type);
    }
}
```

다음과 같이 반복문과 분기문을 사용하여 ProductType에 대한 테스트를 작성했다고 하자.  
모든 ProductType을 순회하면서, 각 케이스에 대해서 containsStockType이 잘 동작하는지 검증한다.

```java
package sample.cafekiosk.spring.domain.product;

class ProductTypeTest {

    @DisplayName("상품 타입이 재고 관련 타입인지를 체크한다.")
    @Test
    void containsStockType() {
        // given
        ProductType[] productTypes = ProductType.values();

        for (ProductType productType : productTypes) {
            if (produtType === ProductType.HANDMADE) {
                // when
                boolean result = ProductType.containsStockType(productType);

                // then
                assertThat(result).isFalse();
            }
            // when
            if (productType == ProductType.BOTTLE || productType == ProductType.BAKERY) {
                // when
                boolean result = ProductType.containsStockType(productType);

                // then
                assertThat(result).isTrue();
            }
        }
    }
}
```

위 경우에는 여러 가지의 테스트 케이스가 하나의 테스트로 작성된 것이라고 볼 수 있다.  
테스트에 분기문이나 반복문이 들어가면, 여러 가지의 주제를 하나의 테스트에 담으려고 시도하는 것으로 보면 된다.  
분기문이나 반복문이 들어가면 논리 구조를 이해하기 위한 노력이 필요해지고, 이로 인해 테스트가 무엇을 검증하고자 하는지, 어떤 환경을 구성하고자 하는지 이해하기 어려워진다.  
만약 테스트 확장이 필요하다면, 뒤에서 소개할 ParameterizedTest를 사용하거나, 테스트를 분리해서 작성해야 한다.

```java
package sample.cafekiosk.spring.domain.product;

class ProductTypeTest {
    @DisplayName("상품 타입이 재고 관련 타입인지를 체크한다.")
    @Test
    void containsStockType() {
        // given
        ProductType givenType = ProductType.HANDMADE;

        // when
        boolean result = ProductType.containsStockType(givenType);

        // then
        assertThat(result).isFalse();
    }

    @DisplayName("상품 타입이 재고 관련 타입인지를 체크한다.")
    @Test
    void containsStockType2() {
        // given
        ProductType givenType = ProductType.BAKERY;

        // when
        boolean result = ProductType.containsStockType(givenType);

        // then
        assertThat(result).isTrue();
    }
}
```

### 완벽하게 제어하기

테스트를 하기 위한 환경을 구성할 때에는, 모든 조건을 완벽하게 제어할 수 있어야 한다.  
현재 시간, 랜덤값을 매개변수로 받게 하거나, 외부 시스템과의 연동을 모킹 처리하는 등의 방법으로 제어 가능한 영역을 넓혀야 한다.

예제에서는 키오스크에서 주문 생성 시, 주문 생성 시간을 내부에서 계산하는 대신, 외부에서 매개변수로 받도록 createOrder 메서드를 오버로딩 했다.

```java
package sample.cafekiosk.unit;

@Getter
public class CafeKiosk {

    private static final LocalTime SHOP_OPEN_TIME = LocalTime.of(10, 0);
    private static final LocalTime SHOP_CLOSE_TIME = LocalTime.of(22, 0);

    private final List<Beverage> beverages = new ArrayList<>();

    ...

    public Order createOrder() {
        return createOrder(LocalDateTime.now());
    }

    public Order createOrder(LocalDateTime currentDateTime) {
        LocalTime currentTime = currentDateTime.toLocalTime();
        if (currentTime.isBefore(SHOP_OPEN_TIME) || currentTime.isAfter(SHOP_CLOSE_TIME)) {
            throw new IllegalArgumentException("주문 시간이 아닙니다. 관리자에게 문의하세요.");
        }

        return new Order(currentDateTime, beverages);
    }

}
```

이렇게 현재 시간을 구하는 부분을 제어 가능한 영역으로 만들었기 때문에, 다음과 같이 주문 성공 케이스와 실패 케이스를 구분하여 테스트를 작성할 수 있었다.

```java
package sample.cafekiosk.unit;

class CafeKioskTest {
    @Test
    void createOrderWithCurrentTime() {
        CafeKiosk cafeKiosk = new CafeKiosk();
        Americano americano = new Americano();
        cafeKiosk.add(americano);

        Order order = cafeKiosk.createOrder(LocalDateTime.of(2023, 1, 17, 10, 0));

        assertThat(order.getBeverages()).hasSize(1);
        assertThat(order.getBeverages().get(0).getName()).isEqualTo("아메리카노");
    }

    @Test
    void createOrderOutsideOpenTime() {
        CafeKiosk cafeKiosk = new CafeKiosk();
        Americano americano = new Americano();
        cafeKiosk.add(americano);

        assertThatThrownBy(() -> cafeKiosk.createOrder(LocalDateTime.of(2023, 1, 17, 9, 59)))
            .isInstanceOf(IllegalArgumentException.class)
            .hasMessage("주문 시간이 아닙니다. 관리자에게 문의하세요.");
    }

}
```
