# 1. Why Kubernetes?

사용자의 트래픽을 예측하고, 이에 맞춰 리소스를 미리 할당해 두는 것은 매우 어려운 일이다.  
또한 트래픽이 몰리는 시간을 기준으로 리소스를 구성하게 되면 평소에 잉여 리소스가 많이 남게 된다.

예를 들어 A, B, C 서비스가 각각 아침, 점심, 저녁 시간에 서버 3개 만큼의 트래픽이 몰린다고 하면, 물리 서버를 사용하는 경우 각 서버당 3개 + 백업 1개로 총 12개의 서버를 운영해야 한다.

만약 이를 쿠버네티스로 운영한다면 각 시간별 평균 리소스 사용량인 4대 + 백업용 1대로 총 5대만 운영하면 된다.  
Auto Scaling 기술을 통해 각 시간마다 트래픽이 몰리는 서비스에 서버가 할당되고, Auto Healing 기술을 통해 장애가 난 서버가 백업 서버로 대체 된다.  
이를 통해 리소스 사용량을 줄이고, 리소스를 효과적으로 관리할 수 있다.

또한 서비스의 새 버전을 배포할 때에는 기존에는 돌고 있는 서버를 하나씩 변경하면서 갈아 끼우는 식으로 작업했다면, 쿠버네티스에서는 Deployment 객체를 통해 이러한 작업이 자동화된다.

# 2. VM vs Container

### 가상화 방법의 차이

서비스가 돌아가는데에는 Host 서버와 그곳에 설치된 Host OS가 존재한다.

VM 사용 시 이를 지원하는 Hypervisor가 설치되어 있고, 그 위에 여러 VM이 떠 있는 형태가 된다.  
각각의 VM에는 Guest OS가 설치되어 있다. 하나의 VM 안에는 여러 개의 서비스가 설치되어 있어서 그 안에서 통신할 수 있다.

컨테이너 사용시 이를 지원하는 docker 등의 도구를 설치하고, 해당 도구를 통해 리눅스의 커널, 리소스 가상화 기술을 사용하여 각각의 컨테이너를 실행하게 된다.  
이 때 컨테이너들은 Host OS를 공유해서 사용하게 되는데, Host OS의 리눅스 버전에 따라 설치되는 리이브러리의 버전이 다를 수 있다는 문제가 있다.  
이에 대한 대책으로 도커는 실행할 서비스에서 필요한 라이브러리를 함께 설치하여 이미지를 생성한다.  
이를 통해 Host OS의 버전과 상관 없이 서비스를 실행할 수 있다.

### 확장 방법에서의 차이

만약 세개의 모듈이 있는 상황에서 하나의 서비스에 대한 확장이 필요하다면, 모놀리틱한 구조로 VM을 사용하는 경우에는 OS를 하나 더 추가로 띄어야할 뿐만 아니라, 확장이 불필요한 다른 모듈까지 포함된 형태로 확장을 해야 한다.

이와 달리 MSA로 컨테이너를 사용하는 경우에는 OS를 추가로 띄어야 할 필요도 없고, 필요한 모듈이 담긴 컨테이너만 확장하면 된다.  
이 경우 자원 측면에서 많은 부분이 절약된다.

# 3. Getting started - Kubernetes - 실습

쿠버네티스 실습을 위해 간단한 노드 앱을 작성해서 Docker 이미지로 말고, Dockerhub에 업로드한다.  
Docker의 다음 명령어로 실행 가능하다.

docker run -d -p 8100:8000 kubetm/hello

쿠버네티스로 컨테이너를 실행하기 위해서는 파드 객체를 구성해야 한다.  
예시 구성 파일 내용은 다음과 같다.

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: hello-pod
  labels:
    app: hello
spec:
  containers:
    - name: hello-container
      image: kubetm/hello
      ports:
        - containerPort: 8000
```

파드 내에서 사용할 이미지를 지정하고, 컨테이너의 포트를 지정한다.

이제 해당 파드를 외부에 노출시키기 위해 서비스 객체를 정의해야 한다.

```yaml
apiVersion: v1
kind: Service
metadata:
  name: hello-svc
spec:
  selector:
    app: hello
  ports:
    - port: 8200
      targetPort: 8000
  externalIPs:
    - 192.168.56.30
```

기존에 생성한 파드를 selector를 통해 선택하고, 8200번 포트로 해당 파드의 8000번 포트의 컨테이너를 노출시킨다.  
외부 노출 IP도 함께 지정했다.

# 4. Kubernetes Overview

쿠버네티스에서는 하나의 서버는 마스터, 나머지 서버는 노드들로 구성되어 하나의 클러스터로 묶이게 된다.  
마스터는 쿠버네티스의 전반적인 기능을 제어하고, 노드는 쿠버네티스의 자원을 제공하는 역할을 한다.  
만약 쿠버네티스의 자원을 늘리고 싶다면 노드를 늘려야 한다.

네임스페이스는 클러스터 내의 쿠버네티스 객체들을 분리하는 역할을 한다.  
다른 네임스페이스에 있는 객체들은 서로 소통이 불가능하다.  
실제로 파드에 서비스를 연결해서 외부와 소통할 수 있는 ip를 발급 받더라도, 다른 네임스페이스의 객체와는 소통이 불가능하다.

쿠버네티스의 파드는 여러 개의 컨테이너로 구성될 수 있고, 각 컨테이너는 하나의 서비스를 담고 있다.  
이 때 파드에 문제가 생기면 파드 전체가 종료되고 재생성 된다.  
이 때 데이터가 날라가게 되는데, 파드에 볼륨을 연결시키면 볼륨에 데이터를 저장해서 유지시킬 수 있다.
