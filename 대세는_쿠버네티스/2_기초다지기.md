# 1. Why Kubernetes?

사용자의 트래픽을 예측하고, 이에 맞춰 리소스를 미리 할당해 두는 것은 매우 어려운 일이다.  
또한 트래픽이 몰리는 시간을 기준으로 리소스를 구성하게 되면 평소에 잉여 리소스가 많이 남게 된다.

예를 들어 A, B, C 서비스가 각각 아침, 점심, 저녁 시간에 서버 3개 만큼의 트래픽이 몰린다고 하면, 물리 서버를 사용하는 경우 각 서버당 3개 + 백업 1개로 총 12개의 서버를 운영해야 한다.

만약 이를 쿠버네티스로 운영한다면 각 시간별 평균 리소스 사용량인 4대 + 백업용 1대로 총 5대만 운영하면 된다.  
Auto Scaling 기술을 통해 각 시간마다 트래픽이 몰리는 서비스에 서버가 할당되고, Auto Healing 기술을 통해 장애가 난 서버가 백업 서버로 대체 된다.  
이를 통해 리소스 사용량을 줄이고, 리소스를 효과적으로 관리할 수 있다.

또한 서비스의 새 버전을 배포할 때에는 기존에는 돌고 있는 서버를 하나씩 변경하면서 갈아 끼우는 식으로 작업했다면, 쿠버네티스에서는 Deployment 객체를 통해 이러한 작업이 자동화된다.

# 2. VM vs Container

### 가상화 방법의 차이

서비스가 돌아가는데에는 Host 서버와 그곳에 설치된 Host OS가 존재한다.

VM 사용 시 이를 지원하는 Hypervisor가 설치되어 있고, 그 위에 여러 VM이 떠 있는 형태가 된다.  
각각의 VM에는 Guest OS가 설치되어 있다. 하나의 VM 안에는 여러 개의 서비스가 설치되어 있어서 그 안에서 통신할 수 있다.

컨테이너 사용시 이를 지원하는 docker 등의 도구를 설치하고, 해당 도구를 통해 리눅스의 커널, 리소스 가상화 기술을 사용하여 각각의 컨테이너를 실행하게 된다.  
이 때 컨테이너들은 Host OS를 공유해서 사용하게 되는데, Host OS의 리눅스 버전에 따라 설치되는 리이브러리의 버전이 다를 수 있다는 문제가 있다.  
이에 대한 대책으로 도커는 실행할 서비스에서 필요한 라이브러리를 함께 설치하여 이미지를 생성한다.  
이를 통해 Host OS의 버전과 상관 없이 서비스를 실행할 수 있다.

### 확장 방법에서의 차이

만약 세개의 모듈이 있는 상황에서 하나의 서비스에 대한 확장이 필요하다면, 모놀리틱한 구조로 VM을 사용하는 경우에는 OS를 하나 더 추가로 띄어야할 뿐만 아니라, 확장이 불필요한 다른 모듈까지 포함된 형태로 확장을 해야 한다.

이와 달리 MSA로 컨테이너를 사용하는 경우에는 OS를 추가로 띄어야 할 필요도 없고, 필요한 모듈이 담긴 컨테이너만 확장하면 된다.  
이 경우 자원 측면에서 많은 부분이 절약된다.
