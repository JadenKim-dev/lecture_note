### 예외 계층

예외의 최상위 부모에는 Object가 있고 그 다음 Throwable의 자식인 Exception, Error가 있다.  
Error의 경우 메모리 부족 등 심각한 오류 상황이 발생한 경우이기 때문에 try-catch 하지 않고 그냥 던져야 하는 오류이다.

에러 핸들링 대상이 되는 것은 Exception과 그 하위 객체들이다.  
Exception은 기본적으로 컴파일러가 체크를 하는 체크 예외이지만(SQLException, IOException), RuntimeException에 한해서만 언체크 예외로 다룬다.

### 예외 기본 규칙

예외가 발생하면 잡아서 처리하거나, 밖으로 던지게 된다.  
잡아서 처리하면 그 이후의 로직은 정상 동작 하지만, 밖으로 던지면 예외가 계속 상위로 전파된다.

이 때 예외 처리는 지정한 예외 뿐만 아니라 그 하위의 예외까지 함께 묶어서 처리한다.  
예를 들어 Exception을 catch로 잡아서 처리하면 그 하위의 자식도 함께 잡힌다.  
또한 체크 예외로 Exception을 던지면 그 하위의 자식도 던질 수 있다.

> 만약 자바의 main 쓰레드에서 예외가 끝까지 잡히지 않고 던져지면 시스템이 종료된다.  
> 웹 어플리케이션 실행 중에는 보통 WAS 단에서 잡아서 처리한다. 

### 체크 예외 기본 이해

RuntimeException을 제외한 Exception의 모든 하위 예외들은 모두 Checked 예외이다.  
Checked 예외가 발생하는 메서드는 해당 예외를 잡아서 처리하거나 예외를 밖으로 던져야 한다.  

```java
public class CheckedTest {

    @Test
    void checked_catch() {
        Service service = new Service();
        service.callCatch();
    }

    @Test
    void checked_throw() {
        Service service = new Service();
        assertThatThrownBy(() -> service.callThrow())
                .isInstanceOf(MyCheckedException.class);
    }

    /**
     * Exception을 상속받은 예외는 체크 예외가 된다.
     */
    static class MyCheckedException extends Exception {
        public MyCheckedException(String message) {
            super(message);
        }
    }

    static class Service {
        Repository repository = new Repository();

        /**
         * 예외를 잡아서 처리하는 코드
         */
        public void callCatch() {
            try {
                repository.call();
            } catch (MyCheckedException e) {
                log.info("예외 처리, message={}", e.getMessage(), e);
            }
        }

        /**
         * 체크 예외를 밖으로 던지는 코드
         */
        public void callThrow() throws MyCheckedException {
            repository.call();
        }
    }

    static class Repository {
        public void call() throws MyCheckedException {
            throw new MyCheckedException("ex");
        }
    }
}
```

이 때 예외를 밖으로 던지기 위해서는 `callThrow() throws MyCheckedException` 형식으로 선언을 해야 한다.  
체크 예외 선언을 누락할 경우 컴파일 에러가 발생해서 빌드 전에 막히게 된다.

Checked 예외를 사용할 경우 개발자가 예외 처리를 빼먹지 않고 고려하도록 하는 장점이 있다.  
다만 모든 예외를 잡거나 던지도록 처리해야 하기 때문에, 신경 쓰고 싶지 않은 예외까지 모두 처리해야 해서 번거롭다.

### 언체크 예외 기본 이해

언체크 예외도 체크 예외와 동일하게 잡아서 처리하거나 밖으로 던지게 된다.  
다만 언체크 예외를 밖으로 던질 경우에는 throws 예외 선언을 하지 않아도 된다는 차이점이 있다.  
언체크 예외의 경우 컴파일러가 체크하지 않기 때문에, throws 예외 선언을 할지는 개발자가 선택할 수 있다.

```java
@Slf4j
public class UncheckedTest {

    @Test
    void unchecked_catch() {
        Service service = new Service();
        service.callCatch();
    }

    @Test
    void unchecked_throw() {
        Service service = new Service();
        assertThatThrownBy(() -> service.callThrow())
                .isInstanceOf(MyUncheckedException.class);
    }

    /**
     * RuntimeException을 상속받은 예외는 언체크 예외가 된다.
     */
    static class MyUncheckedException extends RuntimeException {
        public MyUncheckedException(String message) {
            super(message);
        }
    }

    static class Service {
        Repository repository = new Repository();

        public void callCatch() {
            try {
                repository.call();
            } catch (MyUncheckedException e) {
                //예외 처리 로직
                log.info("예외 처리, message={}", e.getMessage(), e);
            }
        }

        /**
         * 예외를 잡지 않아도 된다.
         * 체크 예외와 다르게 throws 예외 선언을 하지 않아도 된다.
         */
        public void callThrow() {
            repository.call();
        }
    }

    static class Repository {
        public void call() {
            throw new MyUncheckedException("ex");
        }
    }
}
```

언체크 예외를 사용하면 불필요하기 외부 라이브러리의 예외를 참조하지 않아도 된다는 장점이 있다.  
내가 처리하지 못하는 예외는 그냥 던지면 된다.  
다만 개발자가 예외 처리를 누락할 수 있다는 단점이 존재한다.

### 체크 예외 활용

실무에서 대부분의 예외는 런타임 예외로 처리한다.  
비즈니스 상 중요도가 매우 높아서 반드시 처리해야 하는 커스텀 에러를 제외하면 나머지는 모두 런타임 에러로 처리하는 것을 원칙으로 한다.

실무에서 발생하는 예외는 보통 DB 작업에 문제가 생긴 SQLException이나, 네트워크 통신에 문제가 생기는 등 복구할 수 없는 경우가 많다.  
이들은 서비스, 컨트롤러 등에서 잡아서 처리하는 것은 불가능하다.  
그냥 밖으로 던지는게 최선이다. (보통 최상단의 Filter, ControllerAdvice 등에서 적절한 에러메시지를 반환하고 개발자가에게 알람을 보내는 식으로 처리 된다.)

하지만 체크 예외를 사용하면 이를 처리할 수 없는 서비스, 컨트롤러 등 상위 계층에서도 해당 예외를 명시해야 한다.  
이로 인해 상위 계층들에서 체크 예외들에 의존하게 된다.  
대표적으로 SQLException의 경우도 JDBC에 의존적인 예외이다.  
만약 다른 구현 기술을 사용하는 것으로 변경한다면, SQLException이 사용되는 부분도 그것에 맞춰서 모두 변경해야 한다.  
이는 OCP, DI 원칙에 위배된다.

물론 throws Exception 으로 선언하면 Exception 하위의 모든 예외를 던질 수 있어서 의존 관계 문제가 해결되지만, 이렇게 하면 다른 중요한 체크 예외들까지 모두 처리가 되어 버리기 때문에 적절하지 않다.  
위 문제를 해결하기 위해 보통 RuntimeException을 활용한다.
