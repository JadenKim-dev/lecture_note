### 1. 문제점들

지금까지 작성한 트랜잭션 코드에는 많은 문제가 있다.  

```java
import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.SQLException;

@Slf4j
@RequiredArgsConstructor
public class MemberServiceV2 {
private final DataSource dataSource;
    private final MemberRepositoryV2 memberRepository;
    public void accountTransfer(String fromId, String toId, int money) throws SQLException {
        Connection con = dataSource.getConnection();
        try {
            con.setAutoCommit(false);//트랜잭션 시작 //비즈니스 로직
            bizLogic(con, fromId, toId, money); con.commit();//성공시 커밋
        } catch (Exception e) { con.rollback();//실패시 롤백
            throw new IllegalStateException(e);
        } finally {
            release(con);
        }
    }
    private void bizLogic(Connection con, String fromId, String toId, int money) throws SQLException {
        Member fromMember = memberRepository.findById(con, fromId);
        Member toMember = memberRepository.findById(con, toId);
        memberRepository.update(con, fromId, fromMember.getMoney() - money);
        memberRepository.update(con, toId, toMember.getMoney() + money);
    }
}
```

가장 큰 문제는 특정 데이터 접근용 구현 기술(jdbc)과 관련된 코드가 서비스 계층에까지 누수되고 있다는 점이다.  
위 코드에서 서비스 계층은 jdbc 기술인 javax.sql.DataSource , java.sql.Connection , java.sql.SQLException 에 의존하고 있다.  
비즈니스 로직 단위로 트랜잭션을 적용하기 위해 커넥션을 생성하고 commit/rollback 하는 코드가 서비스 계층에 추가되면서 계층의 구분이 모호해졌다.
서비스 계층은 가능한 구현 기술과는 무관한, 순수한 비즈니스 로직만 담고 있어야 한다.  
그래야만 중간에 구현기술이 바뀌어도 서비스 계층에는 변화가 전파되지 않는다.

서비스 로직 중 트랜잭션 동기화를 위해 레포지토리 메서드에서 매개변수로 커넥션을 받게 되는 것도 문제가 된다.  
트랜잭션 없이 autocommit을 사용하는 경우도 있기 때문에 커넥션을 받는 메서드와 그렇지 않은 메서드를 동시에 정의해야 한다.  

또한 코드의 중복도 많이 발생하고 있다.  
트랜잭션이 필요한 비즈니스 로직이 여러개로 늘어난다면 트랜잭션 처리 코드가 중복되어 들어가야 한다.  
또한 repository 내의 커넥션 생성, Statement 생성, 커넥션 닫기 등의 코드가 각 메서드에서 동일한 형태로 반복되고 있다.  
구현 기술이 바뀐다면 이들도 모두 변경의 대상이 된다.

추가적으로, 예외가 누수되고 있다는 점도 문제가 된다.  
지금은 체크 예외인 SQLException을 사용하고 있어서, 서비스 계층에서도 해당 예외를 명시해야 한다.  
SQLException 은 JDBC 전용 기술이기 때문에 추후 JPA 등으로 기술을 변경하면 서비스 계층의 코드도 함께 변경해야 한다.

### 2. 트랜잭션 추상화

서비스 계층에서 트랜잭션을 위해 데이터 접근용 구현 기술에 의존하는 문제를 해결해야 한다.  
실제로 Jdbc와 Jpa에서 트랜잭션을 다루는 방식에 차이가 있다.  

- JDBC : `con.setAutoCommit(false)`
- JPA : `transaction.begin()`

JDBC에서 트랜잭션을 사용하는 코드의 예시는 아래와 같다.  

```java
public void accountTransfer(String fromId, String toId, int money) throws SQLException {
    Connection con = dataSource.getConnection();
    try {
        con.setAutoCommit(false);//트랜잭션 시작 //비즈니스 로직
        bizLogic(con, fromId, toId, money); con.commit();//성공시 커밋
    } catch (Exception e) { con.rollback();//실패시 롤백
        throw new IllegalStateException(e);
    } finally {
        release(con);
    }
}
```

JPA를 사용했을 때의 예시는 아래와 같다.  

```java
public static void main(String[] args) {
    //엔티티 매니저 팩토리 생성
    EntityManagerFactory emf =
        Persistence.createEntityManagerFactory("jpabook");
    EntityManager em = emf.createEntityManager(); //엔티티 매니저 생성 
    EntityTransaction tx = em.getTransaction(); //트랜잭션 기능 획득

    try {
        tx.begin(); //트랜잭션 시작 
        logic(em); //비즈니스 로직 
        tx.commit(); //트랜잭션 커밋
    } catch (Exception e) { 
        tx.rollback();//트랜잭션 롤백
    } finally {
        em.close();//엔티티 매니저 종료
    }
    emf.close(); //엔티티 매니저 팩토리 종료
}

```

두 기술의 인터페이스에 큰 차이가 있기 때문에, 기술을 변경하려면 서비스 계층의 코드를 상당 부분 변경해야 한다.  

서비스 계층에 변경이 전파되는 것을 막기 위해서는 트랜잭션 관리 코드에서 구체적인 기술과 무관한 추상화된 인터페이스를 사용해야 한다.  
인터페이스에서는 트랜잭션 시작, 커밋, 롤백의 핵심 기능만 명시해두고, 각 구현 기술(jdbc, jpa)에 맞게 구현체를 작성하는 식으로 구성해야 한다.  

스프링에서는 이미 트랜잭션 관리를 위한 인터페이스를 정의해두었고, 각 기술에 맞는 구현체도 모두 구현해두었다.
따라서 해당 인터페이스를 사용하면서 원하는 트랜잭션 구현체를 가져다 쓰면 된다.  

스프링에서는 다음의 PlatformTransactionManager 구현체를 사용한다.

```java
package org.springframework.transaction;

public interface PlatformTransactionManager extends TransactionManager {
    TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException;
    void commit(TransactionStatus status) throws TransactionException;
    void rollback(TransactionStatus status) throws TransactionException;
}
```

getTransaction을 통해 트랜잭션을 시작하고, commit, rollback을 통해 커밋 롤백 한다.  

### 트랜잭션 동기화

트랜잭션을 수행하기 위해서는 rollback/commit 하기 전까지 동일한 커넥션을 유지해야 한다.  
기존에는 레포지토리 메서드의 매개변수로 커넥션을 넘겨주는 식으로 커넥션을 유지했다.  
하지만 이로 인해 메서드의 인터페이스가 복잡해졌고, 커넥션을 받는 코드와 받지 않는 코드가 동시에 존재해야 했다.

스프링에서는 이를 해결하기 위해 쓰레드 로컬에서 커넥션 동기화를 수행하는 트랜잭션 동기화 매니저를 사용한다.  
쓰레드 로컬을 사용하기 때문에 각 쓰레드마다 격리되어서 커넥션이 관리된다.  
트랜잭션 매니저는 내부적으로 트랜잭션 동기화 매니저를 사용하여 트랜잭션 동기화를 제공하고 있다.  

간단히 전체 플로우를 살펴보면, 먼저 트랜잭션 매니저에서 Datasource를 통해 커넥션을 생성하고 트랜잭션을 시작한다.  
그 후에는 트랜잭션 매니저에서 트랜잭션 동기화 매니저에 트랜잭션을 시작한 커넥션을 저장한다.  
레포지토리에서는 db 작업 시 트랜잭션 동기화 매니저에서 커넥션을 꺼내서 사용한다.  
이 때 커밋/롤백을 수행하면 트랜잭션 매니저는 동기화 매니저에 저장된 커넥션을 통해 트랜잭션을 닫는다.

### 트랜잭션 문제 해결 - 트랜잭션 매니저1

트랜잭션 매니저를 사용하기 위해 레포지토리에서는 DatasourceUtils를 사용해서 커넥션을 얻어오고, 릴리즈해야 한다.  

```java
public class MemberRepositoryV3 {

    private final DataSource dataSource;

    public MemberRepositoryV3(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    public Member save(Member member) throws SQLException {
        String sql = "insert into member(member_id, money) values (?, ?)";

        Connection con = null;
        PreparedStatement pstmt = null;

        try {
            con = getConnection();
            pstmt = con.prepareStatement(sql);
            pstmt.setString(1, member.getMemberId());
            pstmt.setInt(2, member.getMoney());
            pstmt.executeUpdate();
            return member;
        } catch (SQLException e) {
            log.error("db error", e);
            throw e;
        } finally {
            close(con, pstmt, null);
        }

    }

    private void close(Connection con, Statement stmt, ResultSet rs) {
        JdbcUtils.closeResultSet(rs);
        JdbcUtils.closeStatement(stmt);
        // 트랜잭션 동기화를 사용하려면 DataSourceUtils를 사용해야 한다.
        DataSourceUtils.releaseConnection(con, dataSource);
    }


    private Connection getConnection() throws SQLException {
        // 트랜잭션 동기화를 사용하려면 DataSourceUtils를 사용해야 한다.
        Connection con = DataSourceUtils.getConnection(dataSource);
        log.info("get connection={}, class={}", con, con.getClass());
        return con;
    }
}
```

DataSourceUtils의 getConnection을 호출하면 동기화되어 있는 커넥션이 있으면 이를 획득하고, 없는 경우 새롭게 커넥션을 생성한다.  
DataSourceUtils의 releaseConnection을 호출한 경우에는 동기화된 커넥션은 쓰레드 로컬에 그대로 유지하고, 동기화되지 않은 경우 커넥션을 닫는다.  
이를 통해 트랜잭션을 사용하는 경우와 autocommit 모드로 사용하는 경우를 모두 대응할 수 있다.  
따라서 더이상 레포지토리 메서드에서 파라미터로 커넥션을 받지 않아도 된다.

서비스 계층에서는 이제 TransactionPlatformManager를 사용하기 때문에 객체 생성 시 이를 주입받아야 한다.  
서비스 메서드에서는 getTransaction을 호출해서 트랜잭션을 시작하고, 비즈니스 로직을 수행한 후에 commit, rollback을 호출해서 트랜잭션을 종료한다.  
commit, rollback만 호출하면 알아서 내부적으로 커넥션을 닫아서 리소스를 정리해준다.
