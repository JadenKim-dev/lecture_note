### 1. 트랜잭션 - 개념 이해

보통의 비즈니스 로직은 하나의 작업에 여러개의 sql 실행이 필요하다.  
ex. 송금 -> 양쪽의 잔액을 감소시켜야 함

이 때 일부의 sql이 실패한다면 전체를 롤백시키는 작업이 필요하다.  
ex. A -> B 송금일 때 A의 잔고는 감소시켰지만 B의 잔고를 증가시키는데 실패했다면, A 잔고 감소를 취소시켜야 한다.

트랜잭션은 여러 개의 db 작업을 하나의 작업으로 묶는다.  
이를 통해 작업의 원자성(분리되지 않는 하나의 작업처럼 취급), 일관성(db의 참조 무결성 등의 규칙을 지킴), 격리성(동시에 수행되는 작업이 서로 영향을 주지 않음), 지속성(트랜잭션 성공 시 로그가 남아야 함)을 지킬 수 있게 한다.

### 2. 데이터베이스 연결 구조와 DB 세션

데이터베이스의 클라이언트(was)가 db와 커넥션을 맺게 되면, db 내부에서는 해당 커넥션과 연결된 세션을 만들게 된다.  
해당 커넥션을 통해 db에 전달되는 모든 요청은 해당 세션이 받아서 처리하게 된다.  
세션은 트랜잭션을 시작하고, sql을 실행하고, 커밋 및 롤백을 수행한다.  
커넥션을 닫게 되면 해당 세션이 종료된다.

### 3. 트랜잭션 - DB 예제1 - 개념 이해

트랜잭션을 이용하여 변경(등록, 수정, 삭제)한 데이터는 해당 세션에서만 조회할 수 있는 임시 상태로 반영된다.  
커밋하기 전까지 다른 세션에서는 변경된 데이터를 조회할 수 없다.

커밋을 수행하면 변경 사항이 db에 완전히 반영되어, 다른 세션에서도 변경된 데이터에 접근할 수 있게 된다.  
롤백을 수행하면 모든 변경사항이 초기화되어 트랜잭션 시작 이전 상태로 돌아가게 된다. (등록, 수정, 삭제한 모든 작업이 초기화됨)

### 4. 트랜잭션 - DB 예제2 - 자동 커밋, 수동 커밋

기본적으로 db는 auto commit 모드로 설정되어 있기 때문에 sql 하나만 실행하더라도 이를 감싼 트랜잭션으로 실행하여 내용을 commit해버린다.  
실제로 아무런 설정을 하지 않은 채 insert문을 실행한 뒤 rollback을 실행해도 신규 데이터가 그대로 저장된다.

따라서 commit, rollback 등의 트랜잭션 기능을 직접 사용하기 위해서는 auto commit을 false로 설정해야 한다.  
`set autocommit false;`를 통해 autocommit을 false로 설정하고 insert문 실행 후 rollback을 하면 변경사항이 모두 사라지게 된다.

### 5. 트랜잭션 - DB 예제3 - 트랜잭션 실습

`set autocommit false;`를 통해 트랜잭션을 시작한다. commit 을 실행하기 전까지는 트랜잭션울 시작한 세션에서만 추가된 데이터가 확인되고, commit한 이후에는 다른 세션에서도 확인 가능해진다.

rollback을 실행한 경우에는 새롭게 데이터를 삽입했던 세션에서도 해당 데이터들이 안 보이게 된다

### 6. 트랜잭션 - DB 예제4 - 계좌이체

A가 B에게 계좌이체하는 상황에서, 만약 A의 잔고만 줄어들고 B의 잔고를 늘리는데는 실패한다면 큰 문제가 된다.  
이를 방지하기 위해 해당 작업은 전체가 트랜잭션으로 묶여있어야 한다.

`set autocommit false;`를 통해 트랜잭션을 시작하고, 작업 중간에 sql문 실행에 실패했다면 rollback 실행을 통해 전체 작업을 취소한다.  
만약 실패한 상태로 commit 하면 일부 db 작업이 누락된 상태 그대로 db에 반영된다.

```sql
set autocommit false;
update member set money=10000 - 2000 where id = 1;
update member set money=10000 + 2000 where iddd = 2; //쿼리 예외 발생
rollback; // 전체 작업 취소
```

### 7. DB 락 - 개념 이해

만약 하나의 row에 대해서 트랜잭션을 실행 중일 때 다른 세션에서 해당 row를 변경한다면, 트랜잭션을 commit / rollback 할 때 문제가 발생할 수 있다.  
commit하면 다른 세션에서 작업한 내용이 덮어 씌어질 수 있고, rollback하면 이전 작업 내용으로 돌아가야 할지, 다른 세션 작업 내용으로 바꿔야 할지 모호하다.

이러한 문제를 해결하기 위해 db에는 락이라는 개념이 존재한다.  
특정 로우를 수정하기 위해서 세션은 해당 row에 대한 락을 획득해야 한다.  
트랜잭션이 종료되어 락이 반납되기 전까지는 다른 세션에서는 해당 row의 수정이 불가능하다.

### 8. DB 락 - 변경

한 세션에서 특정 로우를 수정하는 트랜잭션을 진행 중일 때, 다른 세션에서 변경을 시도해도 pending이 걸린 상태로 실행이 되지 않는 것을 확인할 수 있다.

예를 들어 한 세션에서 다음의 sql문을 실행 중이라고 해보자

```sql
# 세션 1에서 수행
set autocommit false;
update member set money=2000 where id = 1;
```

다른 세션에서 다음의 sql문으로 동일한 열을 수정하려고 시도하면 요청이 pending이 걸린다.

```sql
# 세션 2에서 수행
SET LOCK_TIMEOUT 60000;
update member set money=1500 where id = 1;
```

락을 획득한 세션에서 commit 또는 rollback으로 트랜잭션을 종료했을 때, pending 되었던 수정이 실행된다.  
만약 락을 획득하지 못한 상태에서 `SET LOCK_TIMEOUT` 으로 지정한 시간이 지나면 Timeout 에러가 발생하면서 실행에 실패하게 된다.
