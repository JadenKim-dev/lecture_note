### 1. 커넥션 풀 이해

만약 db에 요청을 보낼 때마다 커넥션을 새로 생성한다면 tcp/ip 연결, 로그인 정보 전달 등을 매번 해야 한다.  
이는 시간이 오래 걸리는 작업이기 때문에 서버의 요청 응답 시간이 늦어지게 하는 요인이 될 수 있다.

이 문제를 해결하기 위해 커넥션풀이 등장했다.  
DB에 SQL을 실행하고 싶을 때에는 커넥션 풀에 커넥션을 조회하고, 커넥션을 꺼내와서 SQL 실행만 요청하면 된다.  
이를 통해 요청 처리 시간도 단축하고, DB에 과도한 부담이 가는 것도 예방할 수 있다. (최대 생성 가능한 커넥션 개수를 제한)

### 2. DataSource 이해

Datasource는 connection을 얻어오는 방법을 추상화한 표준 인터페이스이다.  
만약 커넥션을 얻어오는 코드를 직접 작성한다면 해당 코드는 특정 커넥션 풀에 종속적이게 되어서, 만약 추후에 커넥션풀을 다른 종류로 변경하고자 한다면 이에 맞춰서 어플리케이션 코드를 변경해야 한다.  
DriverManager를 이용하여 직접 커넥션을 생성하는 방식에서 커넥션풀을 사용하는 방식으로 커넥션 사용 방식을 변경할 때도 마찬가지로 어플리케이션 코드를 변경하게 된다.  
이는 커넥션을 얻어오는 인터페이스를 DataSource로 추상화함으로써 해결할 수 있다.

### 3. DataSource 예제1 - DriverManager

DriverManagerDatasource를 사용하면 DriverManager도 Datasource 인터페이스를 적용할 수 있다.  
해당 방식의 장점은 설정과 사용 부분을 구분할 수 있다는 점이다.  
기존에는 커넥션을 생성할 때 마다 설정 정보를 넘겨줘야 했다

```java
Connection con1 = DriverManager.getConnection(URL, USERNAME, PASSWORD);
Connection con2 = DriverManager.getConnection(URL, USERNAME, PASSWORD);
```

DriverManagerDatasource 객체를 생성하는 시점에 db url, username, password 등의 설정 정보를 넘기면, 그 다음부터는 해당 객체를 주입 받아서 getConnection 메서드를 호출하기만 하면 된다.

```java
DriverManagerDataSource dataSource = new DriverManagerDataSource(URL,
  USERNAME, PASSWORD);
Connection con1 = dataSource.getConnection();
Connection con2 = dataSource.getConnection();
```

### 4. DataSource 예제2 - 커넥션 풀

커넥션풀 객체를 생성하면 여러 설정 정보들을 입력한 뒤, getConnection을 통해 Connection을 꺼낼 수 있다.

```java
HikariDataSource dataSource = new HikariDataSource();
dataSource.setJdbcUrl(URL);
dataSource.setUsername(USERNAME);
dataSource.setPassword(PASSWORD);
dataSource.setMaximumPoolSize(10);
```

위와 같이 설정해두면 어플리케이션 실행 시점에 쓰레드 풀에 최대 커넥션 개수만큼 커넥션을 채워 넣는다.  
커넥션이 생성되면 getConnection() 을 호출한 클라이언트에 하나씩 할당해서 나눠준다.  
(어플리케이션 실행 시간 단축을 위해 쓰레드 생성은 별도의 쓰레드를 사용한다.)

이 때 커넥션 최대 개수를 초과하여 요청이 들어오면, 해당 클라이언트는 블락되어 유휴 커넥션이 생길 때까지 기다리게 된다

### 5. DataSource 적용

Repository 내에서 Datasource를 주입받고, 이를 이용하여 Connection을 생성하여 사용하도록 구성할 수 있다.

```java
public class MemberRepositoryV1 {
  private final DataSource dataSource;
  public MemberRepositoryV1(DataSource dataSource) {
      this.dataSource = dataSource;
  }

  // getConnection() 메서드를 사용하는 select, insert, update, delete 메서드들

  private Connection getConnection() throws SQLException {
      Connection con = dataSource.getConnection();
      return con;
  }
}
```

Repository는 표준화된 Datasource 인터페이스를 사용하기 때문에 다른 종류의 Datasource로 변경하더라도 Repository 내의 코드는 변경하지 않아도 된다.

레포지토리의 각 메서드는 datasource로부터 커넥션을 얻어와서 sql을 실행한 뒤에 커넥션을 닫는다.  
이 때 DriverManager를 사용한다면 매번 새로운 커넥션을 생성하지만, Connection Pool을 사용하는 경우에는 풀에 다시 반납한 뒤 추후에는 동일한 커넥션을 재활용해서 sql을 실행한다.  
이 때 커넥션은 매번 새로운 프록시 커넥션 객체에 담겨서 제공되지만, 내부에서 작동하는 커넥션은 동일한 커넥션이다.

```bash
get connection=HikariProxyConnection@xxxxxxxx1 wrapping conn0: url=jdbc:h2:...
get connection=HikariProxyConnection@xxxxxxxx2 wrapping conn0: url=jdbc:h2:...
get connection=HikariProxyConnection@xxxxxxxx3 wrapping conn0: url=jdbc:h2:...
```
