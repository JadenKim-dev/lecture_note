### 1. 문제점들

지금까지 작성한 트랜잭션 코드에는 많은 문제가 있다.  

```java
import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.SQLException;

@Slf4j
@RequiredArgsConstructor
public class MemberServiceV2 {
private final DataSource dataSource;
    private final MemberRepositoryV2 memberRepository;
    public void accountTransfer(String fromId, String toId, int money) throws SQLException {
        Connection con = dataSource.getConnection();
        try {
            con.setAutoCommit(false);//트랜잭션 시작 //비즈니스 로직
            bizLogic(con, fromId, toId, money); con.commit();//성공시 커밋
        } catch (Exception e) { con.rollback();//실패시 롤백
            throw new IllegalStateException(e);
        } finally {
            release(con);
        }
    }
    private void bizLogic(Connection con, String fromId, String toId, int money) throws SQLException {
        Member fromMember = memberRepository.findById(con, fromId);
        Member toMember = memberRepository.findById(con, toId);
        memberRepository.update(con, fromId, fromMember.getMoney() - money);
        memberRepository.update(con, toId, toMember.getMoney() + money);
    }
}
```

가장 큰 문제는 특정 데이터 접근용 구현 기술(jdbc)과 관련된 코드가 서비스 계층에까지 누수되고 있다는 점이다.  
위 코드에서 서비스 계층은 jdbc 기술인 javax.sql.DataSource , java.sql.Connection , java.sql.SQLException 에 의존하고 있다.  
비즈니스 로직 단위로 트랜잭션을 적용하기 위해 커넥션을 생성하고 commit/rollback 하는 코드가 서비스 계층에 추가되면서 계층의 구분이 모호해졌다.
서비스 계층은 가능한 구현 기술과는 무관한, 순수한 비즈니스 로직만 담고 있어야 한다.  
그래야만 중간에 구현기술이 바뀌어도 서비스 계층에는 변화가 전파되지 않는다.

서비스 로직 중 트랜잭션 동기화를 위해 레포지토리 메서드에서 매개변수로 커넥션을 받게 되는 것도 문제가 된다.  
트랜잭션 없이 autocommit을 사용하는 경우도 있기 때문에 커넥션을 받는 메서드와 그렇지 않은 메서드를 동시에 정의해야 한다.  

또한 코드의 중복도 많이 발생하고 있다.  
트랜잭션이 필요한 비즈니스 로직이 여러개로 늘어난다면 트랜잭션 처리 코드가 중복되어 들어가야 한다.  
또한 repository 내의 커넥션 생성, Statement 생성, 커넥션 닫기 등의 코드가 각 메서드에서 동일한 형태로 반복되고 있다.  
구현 기술이 바뀐다면 이들도 모두 변경의 대상이 된다.

추가적으로, 예외가 누수되고 있다는 점도 문제가 된다.  
지금은 체크 예외인 SQLException을 사용하고 있어서, 서비스 계층에서도 해당 예외를 명시해야 한다.  
SQLException 은 JDBC 전용 기술이기 때문에 추후 JPA 등으로 기술을 변경하면 서비스 계층의 코드도 함께 변경해야 한다.

### 2. 트랜잭션 추상화

서비스 계층에서 트랜잭션을 위해 데이터 접근용 구현 기술에 의존하는 문제를 해결해야 한다.  
실제로 Jdbc와 Jpa에서 트랜잭션을 다루는 코드에는 큰 차이가 있기 때문에, 이들 사이에서 교체를 하려면 코드에도 큰 변경이 필요하다.

서비스 계층에 변경이 전파되는 것을 막기 위해서는 트랜잭션 관련 코드에서 인터페이스를 사용하는 것으로 변경해야 한다.  
인터페이스에서는 트랜잭션 시작, 커밋, 롤백의 핵심 기능만 명시해두고, 각 구현 기술(jdbc, jpa)에 맞게 구현체를 작성하면 된다.  
스프링에서는 이미 이를 위한 인터페이스를 정의해두었고, 각 기술에 맞는 구현체도 모두 구현해두었다.