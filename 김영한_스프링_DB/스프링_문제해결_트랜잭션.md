### 문제점들

지금까지 작성한 트랜잭션 코드에는 많은 문제가 있다.  

```java
import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.SQLException;

@Slf4j
@RequiredArgsConstructor
public class MemberServiceV2 {
private final DataSource dataSource;
    private final MemberRepositoryV2 memberRepository;
    public void accountTransfer(String fromId, String toId, int money) throws SQLException {
        Connection con = dataSource.getConnection();
        try {
            con.setAutoCommit(false);//트랜잭션 시작 //비즈니스 로직
            bizLogic(con, fromId, toId, money); con.commit();//성공시 커밋
        } catch (Exception e) { con.rollback();//실패시 롤백
            throw new IllegalStateException(e);
        } finally {
            release(con);
        }
    }
    private void bizLogic(Connection con, String fromId, String toId, int money) throws SQLException {
        Member fromMember = memberRepository.findById(con, fromId);
        Member toMember = memberRepository.findById(con, toId);
        memberRepository.update(con, fromId, fromMember.getMoney() - money);
        memberRepository.update(con, toId, toMember.getMoney() + money);
    }
}
```

가장 큰 문제는 특정 데이터 접근용 구현 기술(jdbc)과 관련된 코드가 서비스 계층에까지 누수되고 있다는 점이다.  
위 코드에서 서비스 계층은 jdbc 기술인 javax.sql.DataSource , java.sql.Connection , java.sql.SQLException 에 의존하고 있다.  
서비스 계층은 가능한 구현 기술과는 무관한, 순수한 비즈니스 로직만 담고 있는 것이 적절하다.  
그래야만 중간에 구현기술이 바뀌어도 서비스 계층에는 변화가 전파되지 않는다.  
하지만 비즈니스 로직 단위로 트랜잭션을 적용하기 위해 커넥션을 생성하고 commit/rollback 하는 코드가 서비스 계층에 추가되면서 계층의 구분이 모호해졌다.

서비스 로직 중 트랜잭션 동기화를 위해 레포지토리 메서드에서 매개변수로 커넥션을 받게 되는 문제도 있다.  
이로 인해 동기화가 필요한 메서드와 그렇지 않은 메서드를 동시에 정의해야 했다.  

또한 코드의 중복도 많이 발생하고 있다.  
트랜잭션 처리 코드 뿐만 아니라 repository 내의 커넥션 생성, Statement 생성, 커넥션 닫기 등의 코드도 각 메서드에서 동일한 형태로 반복적으로 나타나고 있다.  
구현 기술이 바뀐다면 이들도 모두 변경의 대상이 된다.

추가적으로, 예외가 누수되고 있다는 점도 문제가 된다.  
지금은 체크 예외인 SQLException을 사용하고 있어서, 서비스 계층에서도 해당 예외를 명시해야 한다.  
SQLException 은 JDBC 전용 기술이기 때문에 추후 JPA 등으로 기술을 변경하면 서비스 계층의 코드도 함께 변경해야 한다. 