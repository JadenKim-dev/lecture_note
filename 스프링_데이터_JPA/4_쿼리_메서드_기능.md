### 메소드 이름으로 쿼리 생성

특정 엔티티에 한정된 메서드가 필요한 경우, 공통 인터페이스 기능으로 해결하는 것이 불가능하다.  
예를 들어 username 일치 조건과 age 비교 조건이 적용된 조회 메서드는 jpql을 이용해서 다음과 같이 구현할 수 있다.

```java
public List<Member> findByUsernameAndAgeGreaterThan(String username, int age) {
    return em.createQuery("select m from Member m where m.username = :username and m.age > :age")
        .setParameter("username", username)
        .setParameter("age", age)
        .getResultList();
}
```

이에 대한 테스트 코드는 다음과 같이 구현할 수 있다.

```java
@Test
public void findByUsernameAndAgeGreaterThan() {
    Member m1 = new Member("AAA", 10);
    Member m2 = new Member("AAA", 20);
    memberJpaRepository.save(m1);
    memberJpaRepository.save(m2);

    List<Member> result =
      memberJpaRepository.findByUsernameAndAgeGreaterThan("AAA", 15);
    assertThat(result.get(0).getUsername()).isEqualTo("AAA");
    assertThat(result.get(0).getAge()).isEqualTo(20);
    assertThat(result.size()).isEqualTo(1);
}
```

스프링 데이터 JPA는 위와 같은 jpql을 이용한 조회 메서드를 자동으로 생성해주는 기능을 지원한다.  
다음과 같이 레포지토리 인터페이스에 메서드를 정의하면, 스프링 데이터 JPA에서 메서드 이름을 읽어서 jpql을 생성하고 실행해준다.

```java
public interface MemberRepository extends JpaRepository<Member, Long> {
    List<Member> findByUsernameAndAgeGreaterThan(String username, int age);
}
```

쿼리 메서드 기능에서 지원하는 필터 조건의 경우 다음의 링크에서 확인할 수 있다.
[쿼리 메서드 필터 조건 링크](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.query-creation)

기본 제공되는 기능들의 사용법은 다음과 같다.  
...에는 findUserBy 처럼 조회 대상에 대한 설명이 들어갈 수 있다.  
다만 설명을 넣는 것은 optional하고, 쿼리에는 영향 주지 않는다.

- 조회: find...By, read...By, query...By, get...By,
    - https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query- methods.query-creation
- COUNT: count...By 반환타입 `long`
- EXISTS: exists...By 반환타입 `boolean`
- 삭제: delete...By, remove...By 반환타입 `long`
- DISTINCT: find...DistinctBy
- LIMIT: findFirst3...By, findFirst...By, findTop...By, findTop3...By
    - https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.limit-

실무에서는 쿼리 메서드 기능을 여러 조건을 붙여서 하드하게 사용하지는 않는다.  
너무 조건이 많이 붙으면 점점 메서드 이름이 길어져서 가시성이 떨어지기 때문이다.  
다만 조건이 1-2개 붙은 간단한 조회 쿼리의 경우, 위 기능을 활용하면 쿼리 구현에 대한 부담을 줄여줘서 매우 편리하다.

또한 쿼리 메서드는 메서드명에서 엔티티의 필드명을 사용하기 때문에, 엔티티의 필드명이 변경되어 메서드명과 불일치하면 어플리케이션 로딩 시점에 에러가 발생한다.
이를 통해 실제로 로직을 실행해보기 전부터 오류를 확인하고 고칠 수 있다는 큰 장점이 있다.

### JPA NamedQuery

JPA의 NamedQuery는 쿼리에 이름을 부여하고, 해당 이름을 통해 쿼리를 호출할 수 있는 기능이다.  
순수한 JPA에서는 다음과 같이 엔티티에 @NamedQuery를 붙여서 사용할 수 있다.

```java
@Entity
@NamedQuery(
    name="Member.findByUsername",
    query="select m from Member m where m.username = :username"
)
public class Member {
    ...
}
```

이렇게 정의한 NamedQuery는 em.createNamedQuery를 통해 호출해서 사용할 수 있다.  
어노테이션에 작성했던 이름을 통해 호출하면, 작성했던 jpql이 실행된다.

```java
public class MemberRepository {

    public List<Member> findByUsername(String username) {
        ...
        List<Member> resultList =
            em.createNamedQuery("Member.findByUsername", Member.class)
                .setParameter("username", username)
                .getResultList();
    }
}
```

스프링 데이터 JPA는 NamedQuery를 보다 편리하게 사용할 수 있도록 지원한다.  
레포지토리에서 다음과 같이 메서드에 @Query를 붙여서, 실행할 NamedQuery를 지정하면 된다.  
이 때 jpql에 바인딩할 파라미터의 경우, 메서드의 파라미터에 @Param을 붙여서 지정하면 된다.

```java
@Query(name = "Member.findByUsername")
List<Member> findByUsername(@Param("username") String username);
```

추가적으로, 스프링 데이터 JPA는 @Query도 생략할 수 있도록 지원한다.  
스프링 데이터 JPA는 제네릭에 지정한 엔티티와 메서드 이름을 바탕으로, `Entity.method` 이름의 NamedQuery를 찾아서 실행한다.  
NamedQuery를 찾을 수 없을 때 직접 메서드를 생성하는 식으로 동작한다.

```java
public interface MemberRepository extends JpaRepository<Member, Long> { //** 여기 선언한 Member 도메인 클래스
    List<Member> findByUsername(@Param("username") String username);
}
```

NamedQuery의 가장 큰 장점은 어플리케이션 로딩 시점에 쿼리에 대한 파싱이 이루어진다는 점이다.  
스프링 데이터 JPA에서는 sql로 파싱한 쿼리를 저장해두고, 호출 시 이를 사용하는 식으로 동직한다.  
이 때 jpql 쿼리에 문법 오류가 있는 경우 예외가 발생하기 때문에, 로딩 시점에서부터 쿼리의 유효성을 검증할 수 있다는 장점이 있다.

다만 실무에서 @NamedQuery는 잘 사용하지 않는다.  
@NamedQuery는 실행할 쿼리를 엔티티에 정의해야 해서, 레포지토리와 엔티티를 오고 가며 쿼리를 확인 해야 한다.  
스프링 데이터 JPA는 직접 레포지토리의 메서드에 쿼리를 지정하는 기능도 제공하기 때문에, 보통 해당 기능을 많이 사용한다.  
해당 방법도 NamedQuery의 장점을 그대로 가지고 있다.

### @Query - 리포지토리 메소드에 쿼리 정의하기

이번엔 레포지토리의 메서드에 직접 쿼리를 지정하는 방법을 알아보자.  
다음과 같이 메서드에 @Query를 달고 실행할 jpql을 작성하면 된다.

```java
public interface MemberRepository extends JpaRepository<Member, Long> {

    @Query("select m from Member m where m.username= :username and m.age = :age")
    List<Member> findUser(
        @Param("username") String username,
        @Param("age") int age
    );
}
```

메서드 자동 생성 기능을 이용하면 조건이 추가될수록 메서드가 점점 길어진다는 단점이 있다.  
이와 달리 @Query를 사용하면 복잡한 정적 쿼리를 사용하는 동시에, 원하는 대로 메서드 이름을 간결하게 구성할 수 있다.  
또한 @Query로 지정한 jpql도 어플리케이션 로딩 시점에 파싱이 되기 때문에, 로딩 시점에 쿼리의 문법 오류를 잡을 수 있다. 

### @Query - 값, DTO 조회하기

@Query를 이용해서 프로퍼티 값을 조회할 때에는, 다음과 같이 값을 조회하는 jpql을 작성하여 적용하면 된다.

```java
@Query("select m.username from Member m")
List<String> findUsernameList();
```

이번에는 @Query를 통해 다음의 dto 타입으로 조회하고 싶다고 하자.  
Member와 Team의 정보를 모두 가지고 있는 dto이다.

```java
package study.datajpa.repository;

@Data
public class MemberDto {
    private Long id;
    private String username;
    private String teamName;
    public MemberDto(Long id, String username, String teamName) {
        this.id = id;
        this.username = username;
        this.teamName = teamName;
    }
}
```

jpql에서 dto를 통해 조회하기 위해서는, 전체 dto 경로를 적고 생성자를 호출하는 식으로 작성해야 한다.  
Member와 Team의 정보가 모두 필요하므로 JOIN 문도 추가해야 한다.

```java
@Query("select new study.datajpa.dto.MemberDto(m.id, m.username, t.name) from Member m join m.team t")
List<MemberDto> findMemberDto();
```

dto를 사용하는 경우에는 QueryDsl을 사용하면 더 간단하게 조회 로직을 작성할 수 있다.

### 파라미터 바인딩

```java
select m from Member m where m.username = ?0 //위치 기반
select m from Member m where m.username = :name //이름 기반
```

```java
import org.springframework.data.repository.query.Param
public interface MemberRepository extends JpaRepository<Member, Long> {
    @Query("select m from Member m where m.username = :name")
    Member findMembers(@Param("name") String username);
}
```

```java
@Query("select m from Member m where m.username in :names")
List<Member> findByNames(@Param("names") List<String> names);
```

```java
List<Member> findByUsername(String name); //컬렉션
Member findByUsername(String name); //단건
Optional<Member> findByUsername(String name); //단건 Optional
```

```java
public List<Member> findByPage(int age, int offset, int limit) {
    return em.createQuery("select m from Member m where m.age = :age order by
m.username desc")
            .setParameter("age", age)
            .setFirstResult(offset)
            .setMaxResults(limit)
            .getResultList();
}

public long totalCount(int age) {
    return em.createQuery("select count(m) from Member m where m.age = :age", Long.class)
            .setParameter("age", age)
            .getSingleResult();
}
```

```java
@Test
public void paging() throws Exception {
    //given
    memberJpaRepository.save(new Member("member1", 10));
    memberJpaRepository.save(new Member("member2", 10));
    memberJpaRepository.save(new Member("member3", 10));
    memberJpaRepository.save(new Member("member4", 10));
    memberJpaRepository.save(new Member("member5", 10));

    int age = 10;
    int offset = 0;
    int limit = 3;

    //when
    List<Member> members = memberJpaRepository.findByPage(age, offset, limit);
    long totalCount = memberJpaRepository.totalCount(age);

    //페이지 계산 공식 적용...
    // totalPage = totalCount / size ... // 마지막 페이지 ...
    // 최초 페이지 ..

    //then
    assertThat(members.size()).isEqualTo(3);
    assertThat(totalCount).isEqualTo(5);
}
```

```java
Page<Member> findByUsername(String name, Pageable pageable); //count 쿼리 사용
Slice<Member> findByUsername(String name, Pageable pageable); //count 쿼리 사용 안함
List<Member> findByUsername(String name, Pageable pageable); //count 쿼리 사용 안함
List<Member> findByUsername(String name, Sort sort);
```

```java
public interface MemberRepository extends Repository<Member, Long> {
    Page<Member> findByAge(int age, Pageable pageable);
}
```

```java
//페이징 조건과 정렬 조건 설정
@Test
public void page() throws Exception {
    //given
    memberRepository.save(new Member("member1", 10));
    memberRepository.save(new Member("member2", 10));
    memberRepository.save(new Member("member3", 10));
    memberRepository.save(new Member("member4", 10));
    memberRepository.save(new Member("member5", 10));

     //when
    PageRequest pageRequest = PageRequest.of(0, 3, Sort.by(Sort.Direction.DESC,
"username"));
    Page<Member> page = memberRepository.findByAge(10, pageRequest);

    //then
    List<Member> content = page.getContent(); //조회된 데이터
    assertThat(content.size()).isEqualTo(3); //조회된 데이터 수
    assertThat(page.getTotalElements()).isEqualTo(5); //전체 데이터 수
    assertThat(page.getNumber()).isEqualTo(0); //페이지 번호
    assertThat(page.getTotalPages()).isEqualTo(2); //전체 페이지 번호
    assertThat(page.isFirst()).isTrue(); //첫번째 항목인가?
    assertThat(page.hasNext()).isTrue(); //다음 페이지가 있는가?
}
```

```java
public interface Page<T> extends Slice<T> {
    int getTotalPages(); //전체 페이지 수
    long getTotalElements(); //전체 데이터 수
    <U> Page<U> map(Function<? super T, ? extends U> converter); //변환기
}
```

```java
public interface Slice<T> extends Streamable<T> {
    int getNumber(); //현재 페이지
    int getSize(); //페이지 크기
    int getNumberOfElements(); //현재 페이지에 나올 데이터 수
    List<T> getContent(); //조회된 데이터
    boolean hasContent(); //조회된 데이터 존재 여부
    Sort getSort(); //정렬 정보
    boolean isFirst(); //현재 페이지가 첫 페이지 인지 여부
    boolean isLast(); //현재 페이지가 마지막 페이지 인지 여부
    boolean hasNext(); //다음 페이지 여부
    boolean hasPrevious(); //이전 페이지 여부
    Pageable getPageable(); //페이지 요청 정보
    Pageable nextPageable(); //다음 페이지 객체
    Pageable previousPageable(); //이전 페이지 객체
    <U> Slice<U> map(Function<? super T, ? extends U> converter); //변환기
}
```

```java
@Query(
    value = "select m from Member m",
    countQuery = "select count(m.username) from Member m"
)
Page<Member> findMemberAllCountBy(Pageable pageable);
```

```java
List<Member> findTop3By();
```

```java
Page<Member> page = memberRepository.findByAge(10, pageRequest);
Page<MemberDto> dtoPage = page.map(m -> new MemberDto());
```

```java
@Query(value = "select m from Member m left join m.team t")
Page<Member> findByAge(int age, Pageable pageable);
```

```sql
select
    m1_0.member_id,
    m1_0.age,
    m1_0.team_id,
    m1_0.username
from
    member m1_0
```

```java
public int bulkAgePlus(int age) {
    int resultCount = em.createQuery(
            "update Member m set m.age = m.age + 1" +
                    "where m.age >= :age")
            .setParameter("age", age)
            .executeUpdate();
    return resultCount;
}
```

```java
@Test
public void bulkUpdate() throws Exception {

    //given
    memberJpaRepository.save(new Member("member1", 10));
    memberJpaRepository.save(new Member("member2", 19));
    memberJpaRepository.save(new Member("member3", 20));
    memberJpaRepository.save(new Member("member4", 21));
    memberJpaRepository.save(new Member("member5", 40));

    //when
    int resultCount = memberJpaRepository.bulkAgePlus(20);

    //then
    assertThat(resultCount).isEqualTo(3);
 }
```

```java
@Modifying
@Query("update Member m set m.age = m.age + 1 where m.age >= :age")
int bulkAgePlus(@Param("age") int age);
```

```java
@Test
public void bulkUpdate() throws Exception {
    //given
    memberRepository.save(new Member("member1", 10));
    memberRepository.save(new Member("member2", 19));
    memberRepository.save(new Member("member3", 20));
    memberRepository.save(new Member("member4", 21));
    memberRepository.save(new Member("member5", 40));

    //when
    int resultCount = memberRepository.bulkAgePlus(20);

    //then
    assertThat(resultCount).isEqualTo(3);
}
```

```java
@Test
public void findMemberLazy() throws Exception {
    //given
    //member1 -> teamA
    //member2 -> teamB
    Team teamA = new Team("teamA");
    Team teamB = new Team("teamB");
    teamRepository.save(teamA);
    teamRepository.save(teamB);
    memberRepository.save(new Member("member1", 10, teamA));
    memberRepository.save(new Member("member2", 20, teamB));

    em.flush();
    em.clear();

    //when
    List<Member> members = memberRepository.findAll();

    //then
    for (Member member : members) {
        member.getTeam().getName();
    }
}
```

```java
//Hibernate 기능으로 확인
Hibernate.isInitialized(member.getTeam())

//JPA 표준 방법으로 확인
PersistenceUnitUtil util =
em.getEntityManagerFactory().getPersistenceUnitUtil();
util.isLoaded(member.getTeam());
```

```java
@Query("select m from Member m left join fetch m.team")
List<Member> findMemberFetchJoin();
```

```java
//공통 메서드 오버라이드
@Override
@EntityGraph(attributePaths = {"team"})
List<Member> findAll();

//JPQL + 엔티티 그래프
@EntityGraph(attributePaths = {"team"})
@Query("select m from Member m")
List<Member> findMemberEntityGraph();

//메서드 이름으로 쿼리에서 특히 유용하다.
@EntityGraph(attributePaths = {"team"})
List<Member> findByUsername(@Param("username") String username);
```

```java
@NamedEntityGraph(name = "Member.all", attributeNodes =
@NamedAttributeNode("team"))
@Entity
public class Member {}
```

```java
@EntityGraph("Member.all")
@Query("select m from Member m")
List<Member> findMemberEntityGraph();
```

```java
@QueryHints(value = @QueryHint(name = "org.hibernate.readOnly", value = "true"))
Member findReadOnlyByUsername(String username);
```

```java
@Test
public void queryHint() throws Exception {
    //given
    memberRepository.save(new Member("member1", 10));
    em.flush();
    em.clear();

    //when
    Member member = memberRepository.findReadOnlyByUsername("member1");
    member.setUsername("member2");

    em.flush(); //Update Query 실행X
}
```

```java
@QueryHints(
    value = {
        @QueryHint(name = "org.hibernate.readOnly", value = "true")
    },
    forCounting = true
)
Page<Member> findByUsername(String name, Pageable pageable);
```

````java
@Lock(LockModeType.PESSIMISTIC_WRITE)
List<Member> findByUsername(String name); ```
````

```java

```
