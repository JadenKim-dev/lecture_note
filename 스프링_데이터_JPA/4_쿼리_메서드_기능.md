### 메소드 이름으로 쿼리 생성

특정 엔티티에 한정된 메서드가 필요한 경우, 공통 인터페이스 기능으로 해결하는 것이 불가능하다.  
예를 들어 username 일치 조건과 age 비교 조건이 적용된 조회 메서드는 jpql을 이용해서 다음과 같이 구현할 수 있다.

```java
public List<Member> findByUsernameAndAgeGreaterThan(String username, int age) {
    return em.createQuery("select m from Member m where m.username = :username and m.age > :age")
        .setParameter("username", username)
        .setParameter("age", age)
        .getResultList();
}
```

이에 대한 테스트 코드는 다음과 같이 구현할 수 있다.

```java
@Test
public void findByUsernameAndAgeGreaterThan() {
    Member m1 = new Member("AAA", 10);
    Member m2 = new Member("AAA", 20);
    memberJpaRepository.save(m1);
    memberJpaRepository.save(m2);

    List<Member> result =
      memberJpaRepository.findByUsernameAndAgeGreaterThan("AAA", 15);
    assertThat(result.get(0).getUsername()).isEqualTo("AAA");
    assertThat(result.get(0).getAge()).isEqualTo(20);
    assertThat(result.size()).isEqualTo(1);
}
```

스프링 데이터 JPA는 위와 같은 jpql을 이용한 조회 메서드를 자동으로 생성해주는 기능을 지원한다.  
다음과 같이 레포지토리 인터페이스에 메서드를 정의하면, 스프링 데이터 JPA에서 메서드 이름을 읽어서 jpql을 생성하고 실행해준다.

```java
public interface MemberRepository extends JpaRepository<Member, Long> {
    List<Member> findByUsernameAndAgeGreaterThan(String username, int age);
}
```

쿼리 메서드 기능에서 지원하는 필터 조건의 경우 다음의 링크에서 확인할 수 있다.
[쿼리 메서드 필터 조건 링크](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.query-creation)

기본 제공되는 기능들의 사용법은 다음과 같다.  
...에는 findUserBy 처럼 조회 대상에 대한 설명이 들어갈 수 있다.  
다만 설명을 넣는 것은 optional하고, 쿼리에는 영향 주지 않는다.

- 조회: find...By, read...By, query...By, get...By,
  - https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query- methods.query-creation
- COUNT: count...By 반환타입 `long`
- EXISTS: exists...By 반환타입 `boolean`
- 삭제: delete...By, remove...By 반환타입 `long`
- DISTINCT: find...DistinctBy
- LIMIT: findFirst3...By, findFirst...By, findTop...By, findTop3...By
  - https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.limit-

실무에서는 쿼리 메서드 기능을 여러 조건을 붙여서 하드하게 사용하지는 않는다.  
너무 조건이 많이 붙으면 점점 메서드 이름이 길어져서 가시성이 떨어지기 때문이다.  
다만 조건이 1-2개 붙은 간단한 조회 쿼리의 경우, 위 기능을 활용하면 쿼리 구현에 대한 부담을 줄여줘서 매우 편리하다.

또한 쿼리 메서드는 메서드명에서 엔티티의 필드명을 사용하기 때문에, 엔티티의 필드명이 변경되어 메서드명과 불일치하면 어플리케이션 로딩 시점에 에러가 발생한다.
이를 통해 실제로 로직을 실행해보기 전부터 오류를 확인하고 고칠 수 있다는 큰 장점이 있다.

### JPA NamedQuery

JPA의 NamedQuery는 쿼리에 이름을 부여하고, 해당 이름을 통해 쿼리를 호출할 수 있는 기능이다.  
순수한 JPA에서는 다음과 같이 엔티티에 @NamedQuery를 붙여서 사용할 수 있다.

```java
@Entity
@NamedQuery(
    name="Member.findByUsername",
    query="select m from Member m where m.username = :username"
)
public class Member {
    ...
}
```

이렇게 정의한 NamedQuery는 em.createNamedQuery를 통해 호출해서 사용할 수 있다.  
어노테이션에 작성했던 이름을 통해 호출하면, 작성했던 jpql이 실행된다.

```java
public class MemberRepository {

    public List<Member> findByUsername(String username) {
        ...
        List<Member> resultList =
            em.createNamedQuery("Member.findByUsername", Member.class)
                .setParameter("username", username)
                .getResultList();
    }
}
```

스프링 데이터 JPA는 NamedQuery를 보다 편리하게 사용할 수 있도록 지원한다.  
레포지토리에서 다음과 같이 메서드에 @Query를 붙여서, 실행할 NamedQuery를 지정하면 된다.  
이 때 jpql에 바인딩할 파라미터의 경우, 메서드의 파라미터에 @Param을 붙여서 지정하면 된다.

```java
@Query(name = "Member.findByUsername")
List<Member> findByUsername(@Param("username") String username);
```

추가적으로, 스프링 데이터 JPA는 @Query도 생략할 수 있도록 지원한다.  
스프링 데이터 JPA는 제네릭에 지정한 엔티티와 메서드 이름을 바탕으로, `Entity.method` 이름의 NamedQuery를 찾아서 실행한다.  
NamedQuery를 찾을 수 없을 때 직접 메서드를 생성하는 식으로 동작한다.

```java
public interface MemberRepository extends JpaRepository<Member, Long> { //** 여기 선언한 Member 도메인 클래스
    List<Member> findByUsername(@Param("username") String username);
}
```

NamedQuery의 가장 큰 장점은 어플리케이션 로딩 시점에 쿼리에 대한 파싱이 이루어진다는 점이다.  
스프링 데이터 JPA에서는 sql로 파싱한 쿼리를 저장해두고, 호출 시 이를 사용하는 식으로 동직한다.  
이 때 jpql 쿼리에 문법 오류가 있는 경우 예외가 발생하기 때문에, 로딩 시점에서부터 쿼리의 유효성을 검증할 수 있다는 장점이 있다.

다만 실무에서 @NamedQuery는 잘 사용하지 않는다.  
@NamedQuery는 실행할 쿼리를 엔티티에 정의해야 해서, 레포지토리와 엔티티를 오고 가며 쿼리를 확인 해야 한다.  
스프링 데이터 JPA는 직접 레포지토리의 메서드에 쿼리를 지정하는 기능도 제공하기 때문에, 보통 해당 기능을 많이 사용한다.  
해당 방법도 NamedQuery의 장점을 그대로 가지고 있다.

### @Query - 리포지토리 메소드에 쿼리 정의하기

이번엔 레포지토리의 메서드에 직접 쿼리를 지정하는 방법을 알아보자.  
다음과 같이 메서드에 @Query를 달고 실행할 jpql을 작성하면 된다.

```java
public interface MemberRepository extends JpaRepository<Member, Long> {

    @Query("select m from Member m where m.username= :username and m.age = :age")
    List<Member> findUser(
        @Param("username") String username,
        @Param("age") int age
    );
}
```

메서드 자동 생성 기능을 이용하면 조건이 추가될수록 메서드가 점점 길어진다는 단점이 있다.  
이와 달리 @Query를 사용하면 복잡한 정적 쿼리를 사용하는 동시에, 원하는 대로 메서드 이름을 간결하게 구성할 수 있다.  
또한 @Query로 지정한 jpql도 어플리케이션 로딩 시점에 파싱이 되기 때문에, 로딩 시점에 쿼리의 문법 오류를 잡을 수 있다.

### @Query - 값, DTO 조회하기

@Query를 이용해서 프로퍼티 값을 조회할 때에는, 다음과 같이 값을 조회하는 jpql을 작성하여 적용하면 된다.

```java
@Query("select m.username from Member m")
List<String> findUsernameList();
```

이번에는 @Query를 통해 다음의 dto 타입으로 조회하고 싶다고 하자.  
Member와 Team의 정보를 모두 가지고 있는 dto이다.

```java
package study.datajpa.repository;

@Data
public class MemberDto {
    private Long id;
    private String username;
    private String teamName;
    public MemberDto(Long id, String username, String teamName) {
        this.id = id;
        this.username = username;
        this.teamName = teamName;
    }
}
```

jpql에서 dto를 통해 조회하기 위해서는, 전체 dto 경로를 적고 생성자를 호출하는 식으로 작성해야 한다.  
Member와 Team의 정보가 모두 필요하므로 JOIN 문도 추가해야 한다.

```java
@Query("select new study.datajpa.dto.MemberDto(m.id, m.username, t.name) from Member m join m.team t")
List<MemberDto> findMemberDto();
```

dto를 사용하는 경우에는 QueryDsl을 사용하면 더 간단하게 조회 로직을 작성할 수 있다.

### 파라미터 바인딩

파라미터 바인딩에는 ?를 사용하는 위치 기반과, 파라미터 이름을 사용하는 이름 기반이 있다.

```java
select m from Member m where m.username = ?0 // 위치 기반
select m from Member m where m.username = :name // 이름 기반
```

다만 위치 기반 바인딩을 사용할 경우, 파라미터가 추가되거나 제거되면서 순서에 혼동이 발생할 수 있다.  
실무에서는 보통 이름 기반 파라미터 바인딩을 사용한다.

스프링 데이터 JPA에서 이름 기반 바인딩은 다음과 같이 사용할 수 있다.  
매개변수에서 @Query를 이용하여 각 파라미터를 바인딩하면 된다.

```java
import org.springframework.data.repository.query.Param
public interface MemberRepository extends JpaRepository<Member, Long> {
    @Query("select m from Member m where m.username = :name")
    Member findMembers(@Param("name") String username);
}
```

JPA에서는 컬렉션 파라미터 바인딩도 지원한다.  
IN 절을 통해 특정 목록으로 조건을 걸어서 엔티티를 조회하는 등의 상황에서, 컬렉션을 바인딩 시에 넘겨줄 수 있다.

```java
@Query("select m from Member m where m.username in :names")
List<Member> findByNames(@Param("names") List<String> names);
```

### 반환 타입

스프링 데이터 JPA는 반환 타입을 유연하게 지원한다.  
컬렉션, 엔티티, Optional 등 필요한 타입으로 유연하게 반환받을 수 있다.  
결과가 단건으로 조회되는 경우에는 세가지 타입을 모두 사용할 수 있다.

```java
List<Member> findByUsername(String name); // 컬렉션
Member findByUsername(String name); // 단건
Optional<Member> findByUsername(String name); // 단건 Optional
```

이 때 각 타입에 따라 반환되는 형식이 다르기 때문에 주의해야 한다.  
조회된 데이터가 없을 때 컬렉션 타입으로 받을 경우 빈 컬렉션이 반환된다.  
이와 달리 엔티티 타입으로 받을 경우에는 null이 반환된다.  
(순수 JPA에서는 NoResultException이 발생하지만, 스프링 데이터 JPA에서는 이를 감싸서 null로 반환해준다).
이 때 컬렉션으로 받으면서 조회 여부 체크를 != null로 수행한다면 언제나 true가 반환된다.

이런 혼동이 가능하기 때문에, 결과가 없을 수 있는 단건 조회 시에는 Optional을 사용하는 것이 좋다.  
Optional이 제공하는 인터페이스를 통해 null인 경우를 처리하는게 적절하다.

또한 반환 타입을 단건(엔티티, Optional)로 지정했는데 결과가 여러 건이면 예외가 발생한다.  
이 때 JPA의 예외가 스프링 예외로 변환되어 발생한다.

### 순수 JPA 페이징과 정렬

순수 sql로 데이터를 정렬하고 페이징해서 가져오는 것은 매우 번잡하고, db 마다 작성 방법도 다르다.  
JPA는 이를 표준화해서 페이징과 정렬을 지원하고 있고, 스프링 데이터 JPA는 이를 더 편리하게 사용할 수 있도록 지원한다.

먼저 순수 JPA로 페이징과 정렬을 적용하는 예시를 살펴보자.  
다음의 조건을 적용한 조회 쿼리를 날려야 하는 상황이라고 하자.

- 검색 조건: 나이가 10살
- 정렬 조건: 이름으로 내림차순
- 페이징 조건: 첫 번째 페이지, 페이지당 보여줄 데이터는 3건

순수 JPA에서는 다음과 같이 정렬 조건을 반영한 jpql을 작성한다.  
그리고 쿼리에 대해서 setFirstResult()로 시작 지점을 지정하고, setMaxResults()로 한 페이지당 개수를 지정하면 된다.

```java
public List<Member> findByPage(int age, int offset, int limit) {
    return em.createQuery("select m from Member m where m.age = :age order by
m.username desc")
            .setParameter("age", age)
            .setFirstResult(offset)
            .setMaxResults(limit)
            .getResultList();
}
```

또한 보통 페이징을 할 때에는 전체 데이터 개수도 함께 가져오므로, count 정보를 가져오는 쿼리도 추가로 작성한다.

```java
public long totalCount(int age) {
    return em.createQuery("select count(m) from Member m where m.age = :age", Long.class)
            .setParameter("age", age)
            .getSingleResult();
}
```

이제 작성한 페이징 및 정렬 로직에 대한 테스트 코드를 작성해보자.  
실제 로직에서는 사용자가 넘겨 준 페이징 정보를 바탕으로 offset, limit를 계산해야 한다.  
또한 페이징 조회를 통해 결과를 얻어온 후에는, 전체 페이지가 몇 개인지, 다음 페이지가 존재하는지 등의 정보를 조회 결과를 바탕으로 직접 계산해야 한다.

```java
@Test
public void paging() throws Exception {
    //given
    memberJpaRepository.save(new Member("member1", 10));
    memberJpaRepository.save(new Member("member2", 10));
    memberJpaRepository.save(new Member("member3", 10));
    memberJpaRepository.save(new Member("member4", 10));
    memberJpaRepository.save(new Member("member5", 10));

    int age = 10;
    int offset = 0;
    int limit = 3;

    //when
    List<Member> members = memberJpaRepository.findByPage(age, offset, limit);
    long totalCount = memberJpaRepository.totalCount(age);

    // 페이지 계산 공식 적용
    // totalPage = totalCount / size ...
    // 마지막 페이지 = ...
    // 최초 페이지 = ..

    //then
    assertThat(members.size()).isEqualTo(3);
    assertThat(totalCount).isEqualTo(5);
}
```

현재는 h2 database를 사용 중이므로 아래와 같이 페이징 쿼리가 실행된다.  
Oracle을 사용하면 이에 맞게 rownum을 사용한 dialect로 sql이 작성되어 실행된다.

```sql
... order by member0_.username desc limit 3
```

### 스프링 데이터 JPA 페이징과 정렬

스프링 데이터에서는 정렬과 페이징을 제공하는 공통 인터페이스가 제공된다.  
대부분의 데이터 저장소는 페이징과 정렬 기능을 지원하기 때문에, 각 기술에 맞게 해당 공통 인터페이스를 구현하여 지원하게 된다.

- `org.springframework.data.domain.Sort` : 정렬 기능
- `org.springframework.data.domain.Pageable` : 페이징 기능 (내부에 `Sort` 포함)

또한 스프링 데이터에서는 특별한 반환 타입들을 제공하여, 페이징 관련 기능을 편리하게 사용할 수 있게 지원한다.  
전체 페이지 중 특정 페이지를 선택해서 조회하는 방식일 때에는 `Page` 타입을 사용하고, 무한 스크롤이나 더보기 버튼으로 추가 데이터를 조회하는 방식일 때에는 `Slice` 타입을 사용한다.  
이 때 Slice는 `limit + 1`개를 조회해서 다음 데이터가 있는지 확인하는 식으로 동작한다.

- `org.springframework.data.domain.Page`: 전체 count 결과를 포함
- `org.springframework.data.domain.Slice` : 전체 count 포함 x, 다음 페이지가 존재하는지 확인 가능(내부적으로 limit + 1조회)
- `List` (자바 컬렉션): 전체 count 포함 x, 결과만 반환

실제로 사용할 때에는 레포지토리에서 원하는 반환 타입을 지정하고, 파라미터로 `Pageable`을 받도록 정의하면 된다.

```java
Page<Member> findByUsername(String name, Pageable pageable); //count 쿼리 사용
Slice<Member> findByUsername(String name, Pageable pageable); //count 쿼리 사용 안함
List<Member> findByUsername(String name, Pageable pageable); //count 쿼리 사용 안함
List<Member> findByUsername(String name, Sort sort);
```

먼저 `Page` 반환 타입을 사용하기 위해 다음과 같이 레포지토리에 메서드를 정의하자.

```java
public interface MemberRepository extends Repository<Member, Long> {
    Page<Member> findByAge(int age, Pageable pageable);
}
```

이에 대한 테스트 코드를 다음과 같이 작성할 수 있다.  
페이징 및 정렬 조건의 경우 Pageable의 구현체인 PageRequest에 담아서 전달하면 된다.  
생성자에 현재 페이지, 조회할 데이터 수, 정렬 조건을 넘겨줘서 객체를 생성하고, 이를 조회 메서드에 넘겨주면 된다.

이러면 넘겨준 조건에 따라 적절한 페이징 조회 쿼리와 count 쿼리가 실행된다.  
(조회 쿼리에는 정렬 조건이 적용되지 않는 식으로 최적화가 되어 있다.)  
조회한 Page 결과에 대해서는 `getContent`, `getTotalElements`, `getNumber`, `getTotalPages`, `isFirst`, `hasNext` 등의 메서드를 통해 원하는 정보를 얻어올 수 있다.

```java
// 페이징 조건과 정렬 조건 설정
@Test
public void page() throws Exception {
    //given
    memberRepository.save(new Member("member1", 10));
    memberRepository.save(new Member("member2", 10));
    memberRepository.save(new Member("member3", 10));
    memberRepository.save(new Member("member4", 10));
    memberRepository.save(new Member("member5", 10));

     //when
    PageRequest pageRequest = PageRequest.of(0, 3, Sort.by(Sort.Direction.DESC,
"username"));
    Page<Member> page = memberRepository.findByAge(10, pageRequest);

    //then
    List<Member> content = page.getContent();
    assertThat(content.size()).isEqualTo(3); // 조회된 데이터 수
    assertThat(page.getTotalElements()).isEqualTo(5); // 전체 데이터 수
    assertThat(page.getNumber()).isEqualTo(0); // 현재 페이지 번호
    assertThat(page.getTotalPages()).isEqualTo(2); // 전체 페이지 번호
    assertThat(page.isFirst()).isTrue(); // 첫번째 페이지인가?
    assertThat(page.hasNext()).isTrue(); // 다음 페이지가 있는가?
}
```

Slice 반환 타입도 동일하게 사용할 수 있다.  
레포지토리에 다음과 같이 메서드를 정의한다.

```java
public interface MemberRepository extends Repository<Member, Long> {
    Slice<Member> findByAge(int age, Pageable pageable);
}
```

테스트 코드는 다음과 같이 작성할 수 있다.  
실행된 쿼리를 확인해보면 데이터 조회 시 limit + 1개를 조회하고, count 쿼리는 실행되지 않은 것을 확인할 수 있다.  
Slice로 받은 데이터에 대해서는 Page에서와 동일한 메서드들을 사용할 수 있다.  
다만 `getTotalElements`, `getTotalPages`처럼 count 조회가 필요한 메서드는 사용할 수 없다.

```java
@Test
public void page() throws Exception {
    //given
    memberRepository.save(new Member("member1", 10));
    memberRepository.save(new Member("member2", 10));
    memberRepository.save(new Member("member3", 10));
    memberRepository.save(new Member("member4", 10));
    memberRepository.save(new Member("member5", 10));

     //when
    PageRequest pageRequest = PageRequest.of(0, 3, Sort.by(Sort.Direction.DESC,
"username"));
    Slice<Member> slice = memberRepository.findByAge(10, pageRequest);

    //then
    List<Member> content = slice.getContent();
    assertThat(content.size()).isEqualTo(3); // 조회된 데이터 수
    assertThat(slice.getNumber()).isEqualTo(0); // 현재 페이지 번호
    assertThat(slice.isFirst()).isTrue(); // 첫번째 페이지인가?
    assertThat(slice.hasNext()).isTrue(); // 다음 페이지가 있는가?
}
```

```java
public interface Page<T> extends Slice<T> {
    int getTotalPages(); //전체 페이지 수
    long getTotalElements(); //전체 데이터 수
    <U> Page<U> map(Function<? super T, ? extends U> converter); //변환기
}
```

```java
public interface Slice<T> extends Streamable<T> {
    int getNumber(); //현재 페이지
    int getSize(); //페이지 크기
    int getNumberOfElements(); //현재 페이지에 나올 데이터 수
    List<T> getContent(); //조회된 데이터
    boolean hasContent(); //조회된 데이터 존재 여부
    Sort getSort(); //정렬 정보
    boolean isFirst(); //현재 페이지가 첫 페이지 인지 여부
    boolean isLast(); //현재 페이지가 마지막 페이지 인지 여부
    boolean hasNext(); //다음 페이지 여부
    boolean hasPrevious(); //이전 페이지 여부
    Pageable getPageable(); //페이지 요청 정보
    Pageable nextPageable(); //다음 페이지 객체
    Pageable previousPageable(); //이전 페이지 객체
    <U> Slice<U> map(Function<? super T, ? extends U> converter); //변환기
}
```

```java
@Query(
    value = "select m from Member m",
    countQuery = "select count(m.username) from Member m"
)
Page<Member> findMemberAllCountBy(Pageable pageable);
```

```java
List<Member> findTop3By();
```

```java
Page<Member> page = memberRepository.findByAge(10, pageRequest);
Page<MemberDto> dtoPage = page.map(m -> new MemberDto());
```

```java
@Query(value = "select m from Member m left join m.team t")
Page<Member> findByAge(int age, Pageable pageable);
```

```sql
select
    m1_0.member_id,
    m1_0.age,
    m1_0.team_id,
    m1_0.username
from
    member m1_0
```

```java
public int bulkAgePlus(int age) {
    int resultCount = em.createQuery(
            "update Member m set m.age = m.age + 1" +
                    "where m.age >= :age")
            .setParameter("age", age)
            .executeUpdate();
    return resultCount;
}
```

```java
@Test
public void bulkUpdate() throws Exception {

    //given
    memberJpaRepository.save(new Member("member1", 10));
    memberJpaRepository.save(new Member("member2", 19));
    memberJpaRepository.save(new Member("member3", 20));
    memberJpaRepository.save(new Member("member4", 21));
    memberJpaRepository.save(new Member("member5", 40));

    //when
    int resultCount = memberJpaRepository.bulkAgePlus(20);

    //then
    assertThat(resultCount).isEqualTo(3);
 }
```

```java
@Modifying
@Query("update Member m set m.age = m.age + 1 where m.age >= :age")
int bulkAgePlus(@Param("age") int age);
```

```java
@Test
public void bulkUpdate() throws Exception {
    //given
    memberRepository.save(new Member("member1", 10));
    memberRepository.save(new Member("member2", 19));
    memberRepository.save(new Member("member3", 20));
    memberRepository.save(new Member("member4", 21));
    memberRepository.save(new Member("member5", 40));

    //when
    int resultCount = memberRepository.bulkAgePlus(20);

    //then
    assertThat(resultCount).isEqualTo(3);
}
```

```java
@Test
public void findMemberLazy() throws Exception {
    //given
    //member1 -> teamA
    //member2 -> teamB
    Team teamA = new Team("teamA");
    Team teamB = new Team("teamB");
    teamRepository.save(teamA);
    teamRepository.save(teamB);
    memberRepository.save(new Member("member1", 10, teamA));
    memberRepository.save(new Member("member2", 20, teamB));

    em.flush();
    em.clear();

    //when
    List<Member> members = memberRepository.findAll();

    //then
    for (Member member : members) {
        member.getTeam().getName();
    }
}
```

```java
//Hibernate 기능으로 확인
Hibernate.isInitialized(member.getTeam())

//JPA 표준 방법으로 확인
PersistenceUnitUtil util =
em.getEntityManagerFactory().getPersistenceUnitUtil();
util.isLoaded(member.getTeam());
```

```java
@Query("select m from Member m left join fetch m.team")
List<Member> findMemberFetchJoin();
```

```java
//공통 메서드 오버라이드
@Override
@EntityGraph(attributePaths = {"team"})
List<Member> findAll();

//JPQL + 엔티티 그래프
@EntityGraph(attributePaths = {"team"})
@Query("select m from Member m")
List<Member> findMemberEntityGraph();

//메서드 이름으로 쿼리에서 특히 유용하다.
@EntityGraph(attributePaths = {"team"})
List<Member> findByUsername(@Param("username") String username);
```

```java
@NamedEntityGraph(name = "Member.all", attributeNodes =
@NamedAttributeNode("team"))
@Entity
public class Member {}
```

```java
@EntityGraph("Member.all")
@Query("select m from Member m")
List<Member> findMemberEntityGraph();
```

```java
@QueryHints(value = @QueryHint(name = "org.hibernate.readOnly", value = "true"))
Member findReadOnlyByUsername(String username);
```

```java
@Test
public void queryHint() throws Exception {
    //given
    memberRepository.save(new Member("member1", 10));
    em.flush();
    em.clear();

    //when
    Member member = memberRepository.findReadOnlyByUsername("member1");
    member.setUsername("member2");

    em.flush(); //Update Query 실행X
}
```

```java
@QueryHints(
    value = {
        @QueryHint(name = "org.hibernate.readOnly", value = "true")
    },
    forCounting = true
)
Page<Member> findByUsername(String name, Pageable pageable);
```

````java
@Lock(LockModeType.PESSIMISTIC_WRITE)
List<Member> findByUsername(String name); ```
````

```java

```
